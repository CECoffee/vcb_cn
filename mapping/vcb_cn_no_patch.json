[
  "书签标题",
  "这是一个测试aaaaaaaaaaaaa",
  "全部展开/折叠",
  "关于",
  "虚拟电路板\n版权所有 © 2022-2023 Reverie Foundry。保留所有权利。\n\n翻译：Xeu\n仅供学习交流使用，禁止用于商业用途。\n\n使用Godot Engine制作。\n第三方许可证位于安装目录。",
  "关闭",
  "虚拟电路板的新功能",
  "虚拟电路板\n版权所有 © 2022 Reverie Foundry。保留所有权利。\n\n翻译：Xeu\n仅供学习交流使用，禁止用于商业用途。\n\n使用Godot Engine制作。\n第三方许可证位于安装目录。",
  "保存",
  "您确定要退出吗？",
  "是",
  "否",
  "光敏性癫痫警告",
  "极少数人在接触某些视觉图像时可能会出现癫痫，包括可能出现在视频游戏中的闪烁灯光或图案。即使没有癫痫或癫痫病史，某些人可能有未被诊断出的疾病，在观看视频游戏时可能引起“光敏性癫痫发作”。\n\n这些癫痫发作可能会出现各种症状，包括头晕、视觉改变、眼睛或面部抽搐、胳膊或腿部的抽搐或颤动、迷失方向、困惑或暂时失去意识。癫痫发作还可能导致意识丧失或痉挛，从而造成摔倒或撞到附近物体而受伤。\n\n如果您出现任何这些症状，请立即停止游戏并咨询医生。家长应注意或询问他们的孩子是否出现上述症状。相较成年人，儿童和青少年更有可能出现这些癫痫发作。采取以下预防措施可降低光敏性癫痫发作的风险：在光线充足的房间中玩游戏；如果感到昏昏欲睡或疲劳，不要玩游戏。\n\n如果您或您的亲属有癫痫或癫痫病史，请在游戏前咨询医生。",
  "不再显示此警告",
  "设置",
  "窗口",
  "全屏",
  "无边框",
  "垂直同步",
  "帧率限制器",
  "UI缩放",
  "1倍",
  "图形",
  "网格",
  "发光",
  "动态背景",
  "文本编辑器",
  "汇编字体大小",
  "笔记字体大小",
  "快捷键",
  "操作",
  "按键或按钮",
  "操作名称",
  "章节标题",
  "汇编编辑器",
  "绑定操作时，按\\\"Esc \\\"取消，按\\\"Backspace \\\"清除",
  "重置",
  "放弃未保存的更改？",
  "放弃",
  "取消",
  "警告",
  "确定",
  "选项",
  "0",
  "切换书签",
  "在外部编辑程序集",
  "从与项目相同路径的文本文件中加载程序集，文件以 \\\".vcbasm\\\" 结尾",
  "从与项目相同路径的二进制文件中加载虚拟内存，文件以 \\\".虚拟面包板mem\\\" 结尾",
  "使用外部基础虚拟内存",
  "持久虚拟内存",
  "外部程序集和虚拟内存",
  "跟随虚拟内存地址",
  "无错误。",
  "L 1\nC 1",
  "删除",
  "错误状态",
  "上一页",
  "下一页",
  "图层",
  "图层逻辑",
  "高层装饰",
  "低层装饰",
  "橡皮擦工具",
  "撤销\n$ed_undo",
  "重做\n$ed_redo",
  "工具",
  "绘图工具",
  "阵列工具\n$ed_tool_阵列工具",
  "铅笔工具\n$ed_tool_铅笔工具",
  "橡皮擦工具\n$ed_tool_橡皮擦工具",
  "颜色拾取工具（Alt）",
  "选择工具\n$ed_tool_selection",
  "填充工具\n$ed_tool_bucket",
  "游标信息",
  "悬停的墨水 ",
  "无",
  "位置 ",
  "X",
  "2000",
  "Y",
  "1024",
  "墨水",
  "空间优化",
  "交叉\n$ed_阵列工具_交叉",
  "隧道",
  "网格",
  "总线（右键单击更改颜色）",
  "追踪",
  "写入\n$ed_阵列工具_Write",
  "读取\n$ed_阵列工具_read",
  "导线（右键单击更改颜色）",
  "门",
  "缓冲区",
  "与",
  "或",
  "异或",
  "反转门",
  "非",
  "与非",
  "或非",
  "异或非",
  "通用组件",
  "锁存器 ON",
  "锁存器 OFF",
  "时钟",
  "时钟间隔（时钟周期）",
  "LED",
  "LED调色板",
  "000000，ffffff，ff0000，00ff00，0000ff，ff0000，00ff00，0000ff，ff0000，00ff00，0000ff，ff0000，00ff00，0000ff，ff0000，00ff00",
  "0/16",
  "计时器",
  "计时器间隔（毫秒）",
  "随机",
  "随机种子",
  "使用时间作为种子",
  "断点",
  "无线（右键单击更改频道）",
  "注释",
  "填充器",
  "桶",
  "画笔",
  "大小",
  "8",
  "形状",
  "方形画笔形状",
  "菱形画笔形状",
  "圆形画笔形状",
  "过滤器",
  "阵列",
  "重复",
  "1",
  "角度",
  "更改角度\n$ed_阵列工具_rotate_right",
  "偏移",
  "空间Y",
  "自动交叉切换\n$ed_阵列工具_toggle_auto交叉",
  "旋转",
  "轴约束角度",
  "轴约束切换",
  "自动交叉",
  "仿真",
  "鼠标交互模式",
  "在按下鼠标按钮时切换锁存器状态",
  "切换",
  "在按下鼠标按钮时将锁存器状态设置为开，并在释放按钮时立即设置为关",
  "按下",
  "统计信息",
  "视图",
  "切换值的视图模式：绝对值，百分比。",
  "绝对值",
  "切换顺序的视图模式：默认（电路编辑器顺序），降序，升序。",
  "默认",
  "绘制的总区域。不包括带有注释和填充器的单元格。",
  "单元格：123",
  "123",
  "电路中唯一导线和组件的总数。",
  "实体：123",
  "选择",
  "复制选择",
  "粘贴选择",
  "选择重复",
  "删除选定内容",
  "应用选定内容",
  "变换",
  "向左旋转选定内容",
  "向右旋转选定内容",
  "镜像",
  "水平镜像选定内容",
  "垂直镜像选定内容",
  "蓝图字符串",
  "将选定内容复制为文本到剪贴板",
  "从剪贴板文本粘贴选定内容",
  "复制和粘贴蓝图时包含装饰图层",
  "选项",
  "拖放",
  "装饰",
  "事件日志",
  "Tick 1026264\n达到断点：128，2040",
  "反转",
  "全部",
  "清除",
  "保存电路",
  "inpt",
  "Lorem ipsum.",
  "目录",
  "流程控制 II",
  "在示例图像中，我们可以看到两个组件之间的简单连接：顶部的锁存器将其状态输出到黄色迹线，因为在锁存器和迹线之间有写入墨水。\n\n底部的缓冲器接收来自黄色迹线的信号作为输入，因为在迹线和缓冲器之间有读取墨水。\n\n在这个示例中，信号将从锁存器流向缓冲器，但反之不行。",
  "将此电路粘贴到电路板中",
  "图像描述",
  "切换目录",
  "开始",
  "结束",
  "用户指南",
  "在本指南中，您将学习有关 [i]虚拟电路板[/i] 的所有必要知识。",
  "图例和电路",
  "用户指南中的一些页面使用图像来辅助文本说明。这些图像有编号，并且可以称为 [i]图例[/i] 或 [i]电路图[/i]。[i]电路图[/i] 图像的右上角有一个按钮，我们可以点击它，将示例电路粘贴到电路板上进行仔细检查。",
  "图例 1 - 虚拟面包板启动屏幕",
  "电路 1 - 入门电路",
  "介绍",
  "关于[i]虚拟电路板[/i]的基础知识",
  "编辑和模拟",
  "[t]虚拟电路板[/t]分为两个模式：编辑和模拟。\n\n在[t]编辑[/t]模式下，我们可以使用绘图工具修改电路，并使用组合编辑器编写程序。在[t]模拟[/t]模式下，我们可以看到电路运行并与之交互。\n\n我们可以通过点击游戏界面中模拟控制区域的[t]编辑/模拟[/t]按钮在编辑模式和模拟模式之间切换。\n\n进入模拟模式可能需要几秒钟，因为游戏需要[t]编译[/t]电路。",
  "模拟引擎",
  "[t]虚拟电路板[/t]配备了高性能的事件驱动[t]模拟引擎[/t]。\n\n这个模拟是[t]确定性的[/t]，这意味着给定的电路每次模拟时都会以完全相同的方式进行，不受任何随机因素影响其时序。\n\n由于是[t]事件驱动[/t]，该引擎仅处理电路的活动部分，使其每秒更新[t]数百万次[/t]，这取决于玩家的硬件配置。\n\n模拟的时钟频率（速度）可以轻松调整。模拟还可以暂停，并手动按给定的步骤前进。",
  "用户界面",
  "介绍游戏的用户界面",
  "导航和快捷键",
  "[t]平移[/t]\n按住[i]鼠标中键[/i]并拖动鼠标可平移视图。或者，我们也可以使用箭头键来移动摄像机。\n\n[t]缩放[/t]\n旋转[i]鼠标滚轮[/i]上下滚动可进行缩放，或使用[i](\u003d)[i]和[i](-)[/i]键。缩放与鼠标光标位置对齐。\n\n[i]注意：相机控制可以在快捷菜单中重新绑定。[/i]\n\n[t]快捷菜单[/t]\n游戏的快捷键列在[i]快捷菜单[/i]中，可以在其中重新映射它们。快捷菜单选项卡可通过界面右上角的选项菜单[i](齿轮图标)[/i]访问。",
  "停靠系统",
  "右键单击行为",
  "某些UI元素在右键单击时会展现[t]二次行为[/t]，例如控制模拟速度的滑块小部件，右键单击后将变为数字输入字段，以便精确控制时钟频率。\n\n可以通过鼠标悬停在具有替代操作的UI元素上来识别它们，它们的鼠标指针将显示为[i]加号和黄色颜色[/i]。",
  "虚拟电路",
  "[t]虚拟电路板[/t]中的电路工作原理。",
  "基于绘图的界面",
  "在[t]虚拟面包板[/t]中，我们通过在一个被称为[t]Board[/t]的方形画布上使用特定的颜色[t]墨水[/t]来构建电路。\n大多数墨水要么是[t]组件[/t]，比如逻辑门，要么是用于它们之间传递信号的[t]导线[/t]，但也有一些不是[t]实体[/t]的墨水，即它们不是需要模拟的逻辑对象。这些类型的墨水可以分为两组：[t]空间优化墨水[/t]（由可以压缩电路的墨水组成）和[t]注释墨水[/t]，它们只是静态墨水，不与其他任何墨水交互。\n在接下来的页面中，我们将学习有关组件和导线的所有知识；墨水 和实体之间的关系；实体之间的连接方式；以及可用的组件类型，包括它们的行为。然后，我们将介绍空间优化墨水，以及如何利用它们来构建紧凑的电路。",
  "组件和导线",
  "[t]组件[/t]和[t]导线[/t]是[t]虚拟面包板[/t]电路的基础。\n[t]组件[/t]是设备，它们根据一个或多个外部输入来执行逻辑操作以改变它们的状态和输出。八种标准逻辑门都是 组件，但[t]虚拟面包板[/t]还实现了一些其他特殊的 组件。\n[t]导线[/t]是[t]虚拟面包板[/t]中 PCB 上印制的导线的等效物。导线传导信号，用于将组件连接到彼此。",
  "墨水和实体 I",
  "相同类型的 组件墨水在相邻绘制时将变成一个[t]单个实体[/t]。在 [i]电路 1[/i] 中，有 4 组 或门墨水，它们在模拟时将变成 4 个单独的 组件。\n我们可以看到实体可以拥有[t]任何形状或大小[/t]，只要它们的墨水是邻居关系。\n不同类型的组件墨水（如 OR 和 XOR）在放置在一起时不会合并。",
  "电路 1 - 相邻的墨水合并为一个实体",
  "墨水和实体 II",
  "与组件不同，即使导线的墨水不完全相同，它们也会变成一个[t]单个实体[/t]，这是因为导线有 16 种颜色变体，除此之外还有两个特殊的线路墨水（Write 和 Read），用于指示连接应该在哪里进行以及信号流的方向。\n在下面的电路中有四条导线。它们都有流控制墨水（仍然属于导线），沿着它们散布。",
  "电路 1 - 不同颜色的导线将合并在一起",
  "流程控制 I",
  "在[t]虚拟面包板[/t]中，当组件和导线并排放置时，它们不会自动连接，而是需要一个中间的墨水来指示信号流的方向，从而实现对信号传输的精细控制。\n用于流控制的墨水被称为 Write 和 Read。它们的名称是从组件的角度命名的，组件产生信号并将其写入导线，换句话说，它们在导线中[color\u003d#e06666][b]写入Write[/b][/color] 它们的[color\u003d#e06666][b]输出[/b][/color]。当信号到达目标位置时，组件会[color\u003d#6fa8dc][b]读取Read[/b][/color] 它们的[color\u003d#6fa8dc][b]输入[/b][/color]。请参考下面的例子：\n组件-\u003e [color\u003d#e06666][b]Write[/b][/color] -\u003e线路-\u003e [color\u003d#6fa8dc][b]Read[/b][/color] -\u003e 组件",
  "需要注意的是，[iw]Write[/iw] 和 [ir]Read[/ir]墨水仍然是导线，尽管它们具有连接的特殊行为。\n当 [iw]Write[/iw] 或 [ir]Read[/ir]墨水在线路的中间位置时，它们不会在线路的两侧创建连接，因为[t]连接只在导线和组件之间进行[/t]。\n在线路的中间使用 [iw]Write[/iw] 或 [ir]Read[/ir]墨水只是线路本身的另一部分，就像其他 16 种线路变体一样。",
  "电路 1 - 由三种颜色变体组成的单一导线，以及特殊的追写和追读墨水",
  "流程控制 III",
  "在 [i]电路 1[/i] 中，我们可以看到两个组件之间的简单连接：顶部的锁存器输出其状态到黄色的 线路，因为在锁存器和线路之间有一个 [color\u003d#e06666][b]Write[/b][/color]墨水。\n底部的 Buffer 从黄色的线路接收信号作为输入，因为在线路和 Buffer 之间有一个 [color\u003d#6fa8dc][b]Read[/b][/color]墨水。",
  "电路 1 - 在此示例中，信号将从锁存器流向缓冲器，但反之则不行",
  "流程控制 IV",
  "流控制墨水必须直接与组件相接触，也就是说，一个 [color\u003d#e06666][b]Write[/b][/color] 或 [color\u003d#6fa8dc][b]Read[/b][/color]墨水的四个[t]立即相邻的单元格[/t]之一必须是 组件，以便与其形成连接。当我们开始使用空间优化墨水 时，这一点非常重要。",
  "不可计数连接 I",
  "组件可以[t]写出(Write)[/t]到导线，或者从导线[t]读入(Read)[/t]，或者[t]同时输入和输出[/t]，但它们[t]仅建立一次连接[/t]。这意味着它们要么连接（以三种可能的方式之一），要么不连接。\n换句话说，两个实体之间的连接是[t]不可计数的[/t]，无论它们有多少接触点或接触面积有多大。",
  "不可计数连接 II",
  "LED组件根据其激活的输入数量更改颜色。在 [i]电路 1[/i] 顶部的两个示例中，LED 的颜色相同，因为它们都只接收来自一个线路的信号。\n底部的 LEDs 有不同的颜色，因为它们都接收[t]3 个信号而不是一个[/t]。在左侧版本中，添加了两个其他导线，而在右侧版本中，信号先经过一个 Buffer，然后连接到 LED 的 3 个独立导线。",
  "电路 1 - LED的颜色会根据活动输入的数量而改变",
  "电路 2 - 另一个使用XOR门的例子",
  "多重输入输出",
  "组件和导线都支持[t]多输入和多输出连接[/t]，包括通常只有两个输入和一个输出的逻辑门。当有任何一个组件向导线写入时，导线就处于活动状态，实际上它们的行为类似于 OR 门。\n在下一页中，我们将看到游戏中每个门组件根据其输入的行为。然后我们将看看一般组件及其特殊行为。",
  "门电路组件",
  "下面我们可以看到每个门根据其输入的行为。\nA \u003d 活动输入数目，T \u003d 总输入数目\n[t]BUFFER -[/t][i]A \u003e 0[/i]\n[t]AND -[/t][i]A \u003e 0 \u0026\u0026 A \u003d\u003d T[/i]\n[t]OR -[/t][i]A \u003e 0[/i]\n[t]XOR -[/t][i]A % 2（奇数个活动输入）[/i]\n\n[t]NOT -[/t][i]!BUFFER[/i]\n[t]NAND -[/t][i]!AND[/i]\n[t]NOR -[/t][i]!OR[/i]\n[t]XNOR -[/t][i]!XOR[/i]\n\n你可能已经注意到 Buffer 和 Or 门（以及它们的反向对应物）具有完全相同的行为，所以你可能会想为什么游戏中同时出现了它们两个。答案是[t]可读性[/t]。如果我们只使用 Buffer 来延迟信号并防止反流，我们可以使我们的电路更易于理解，同时将 Or 门保留在其预期的用例中。\n但是，如果我们抛开可读性，我们还可以利用组件的冗余性来进一步[t]压缩[/t]我们的电路，因为我们可以拥有两个\\\"或门\\\" 或两个 \\\"缓冲器\\\" 并排",
  "通用组件I",
  "除了基本逻辑门外，[t]虚拟面包板[/t]还提供了几种[t]General 组件[/t]，它们使我们能够在电路中实现特殊的行为。现在我们来看看每个组件的功能。\n其中一些组件具有可以通过 [i]右键单击[/i]在 [i]电路 编辑面板[/i] 上更改的属性。这些属性是 [i]全局应用于所有实例[/i]的，即在板上的所有该组件实例上都适用。\n[t]锁存器 ON/OFF -[/t][i]在任何输入的上升沿上切换状态[/i]。\n在模拟中，我们可以使用鼠标与锁存器进行交互。有两种交互模式：切换模式（Toggle），使锁存器切换状态；和按压模式（Press），将保持锁存器处于激活状态，直到左键按下，或直到锁存器被其输入之一切换。锁存器有 ON 和 OFF 两个变种，它们的行为完全相同，只是在模拟开始时 ON 版本处于激活状态。\n[t]Clock -[/t][i]每 N 个 tick 切换一次[/i]。\n时钟间隔可以在右键菜单中调整。\n[t]LED -[/t][i]当活动输入数目 \u003e 0 时激活[/i]。\n在模拟中，其颜色将与活动输入的数量匹配，最多为 15，可以在 LED 的右键菜单中自定义颜色，并应用于板上的所有 LED。",
  "通用组件II",
  "[t]Timer -[/t][i]每 N 个实际毫秒切换一次[/i]。\n计时器间隔可以在右键菜单中调整。\n[t]Random -[/t][i]在任何输入的上升沿上随机切换[/i]。\n默认情况下，组件使用唯一的基于时间的种子，但是可以在右键菜单中禁用，并改为使用用户定义的种子。\n[t]Breakpoint -[/t][i]当活动输入数目 \u003e 0 时激活[/i]。\n在其自身状态的上升沿上触发断点（不是其输入的上升沿），这将暂停模拟并在事件日志中报告事件。\n[t]Wireless (0 to 3) -[/t][i]当活动输入数目 \u003e 0 时激活[/i]。\n这四种无线墨水的行为都像一个全局连接的 Or 门。",
  "到目前为止，我们已经学会了使用多种[t]线路和组件墨水[/t]来创建[t]虚拟面包板[/t]中的电路的基础知识，这已经足够构建一些非常简单的电路了。然而，很快我们会发现受到板上二维空间的物理限制，最大的挑战是如何在其他导线阻挡的情况下使用导线来连接不同的 组件。\n这就是[t]空间优化墨水[/t]发挥作用的地方，它们给了我们在[t]虚拟面包板[/t]中创建紧凑电路所需的自由。在接下来的页面中，我们将看看这个组中的每个墨水，从最基础的交叉开始。但首先，你应该知道：\n[t]1.[/t]尽管使用空间优化墨水与导线更常见，但它们与组件[i]使用方式相同[/i]。\n[t]2.[/t]除了 Bus 外，空间优化墨水[i]在并排放置时不会相互作用[/i]，需要在它们之间放置线路、组件或 bus。",
  "交叉墨水",
  "[t]交叉 Cross墨水[/t]可以放置在导线或组件[t]交叉点[/t]的中心位置，以允许它们在相互交叉时独立存在。交叉墨水只能有一个像素宽，并且必须至少相隔一个像素，即不能连接成链状或堆叠。\n在 [i]电路 1[/i] 顶部的两个示例中，我们可以看到有效使用 交叉墨水来防止垂直和水平实体在交叉时合并。底部两个示例展示了 交叉墨水的无效用法。\n不要忘记 交叉墨水也可以与 组件（如逻辑门）一起使用，如 [i]电路 2[/i] 中所示。",
  "电路 1 - 顶部是有效的交叉放置方式，底部是无效的",
  "电路 2 - 一个连接到三根导线的AND门",
  "隧道墨水",
  "[t]隧道 Tunnel[/t]的行为与 交叉墨水类似，但是基于[t]入口和出口对应[/t]的概念，这些点可以放置得更远。\n例如，触碰一个 隧道墨水的逻辑门、线路或 bus（入口）的左侧将连接到离入口右侧最近的具有相同类型墨水的第一个 隧道（出口），在入口和出口之间的空间中可以是任何东西，甚至可以是其他类型的墨水，如[t]不同墨水的其他隧道[/t]，如 [i]电路 1[/i] 中所示。",
  "电路 1 - 不同颜色的导线通过隧道",
  "网格墨水",
  "[t]Mesh[/t]是与 Wireless墨水相似的更多功能替代品。它与 隧道 类似，允许触碰 meshes 的导线、buses 和组件在板上[t]不同位置[/t]上合并在一起。",
  "电路 1 - 通过网格进行远程连接的导线",
  "总线墨水",
  "[t]总线 Bus[/t]墨水允许多个门和导线[t]通过相同的空间[/t]，板上有 6 种颜色变种的 Bus，就像不同颜色的导线一样，在接触时也会合并在一起。",
  "电路 1 - 多个实体可以使用总线通过相同的单元",
  "注释墨水",
  "最后，[t]虚拟面包板[/t]还提供了一些不与电路交互的墨水，但可用于美观或文档目的：\n[t]注释[/t]- 用于在板上绘制注释。\n[t]填充[/t]- 用于填充电路中墨水之间的空白空间，因此它也可以涂在装饰层上。\n装饰层和填充层的墨水行为相同，可以互换使用，上述描述只是建议的用法。这两种相似的墨水存在的原因是可以使用绘图工具的 过滤器 选项仅删除其中一种而保留另一种。\n为方便起见，该类别中还提供了[t]None[/t]墨水（即空白空间），在过滤器中使用时最有用，只限制绘制到空白区域。",
  "编辑",
  "在[t]虚拟面包板[/t]中构建电路。",
  "[t]虚拟面包板[/t]拥有多种绘图工具，使构建电路成为一项轻松的任务，它们包括：\n\n[t]阵列工具[/t]- 一个高度可定制的工具，可以同时绘制多个像素。\n[t]铅笔工具[/t]- 使用大画笔绘制。\n[t]橡皮擦工具[/t]- 从板上擦除像素。\n[t]颜色拾取工具[/t]- 选择一种墨水使其成为活动墨水。\n[t]选择工具[/t]- 移动、复制、粘贴、复制等。\n[t]填充工具[/t]- 用相同颜色填充区域。\n\n某些工具还有一些特殊功能，比如[t]过滤器[/t]。",
  "阵列工具",
  "[t]阵列工具[/t]是游戏中最多功能的工具。它旨在使[t]绘制多条迹线[/t]或均匀间隔的元件更加容易。\n\n在工具选项中，我们可以更改同时绘制的像素数量，以及它们的间距和角度。我们还可以启用非常方便的[t]自动交叉[/t]选项，该选项会在我们在非空间上绘制时自动放置[t]交叉墨水[/t]。\n\n在绘制时按住[t]Shift[/t]键可以激活[t]轴约束[/t]，使直线绘制更容易。",
  "[t]过滤器[/t]是阵列工具、铅笔工具和橡皮擦工具的一项功能，它允许我们指定要覆盖的墨水。\n\n这使得轻松更改迹线的颜色而不影响周围的颜色变得非常容易。它还使我们能够在不小心覆盖其他东西的情况下，专门在空白区域绘制。",
  "蓝图",
  "[t]蓝图[/t]是一种简单的方法，可以在不必发送整个项目文件的情况下与他人共享我们电路的小部分。它们通过将电路的选定部分复制到[t]文本剪贴板[/t]中，然后我们可以按照希望与他人共享的方式分享这些剪贴板内容。逆向过程同样简单，只需要将文本复制到剪贴板，然后点击按钮将蓝图粘贴回电路板。\n\n[t]Blueprint[/t]功能通过[t]选择工具[/t]获得。\n\n[i]注意：蓝图规范在用户指南的附录章节中提供。[/i]",
  "当游戏处于模拟模式时，组件和迹线墨水的颜色将与编辑器中的颜色不同，以表示它们的激活状态。当实体（例如组件或迹线）处于[t]ON[/t]状态时，墨水将具有鲜艳的颜色，而[t]OFF[/t]状态时墨水将呈深色。\n\n但是，我们可以在编辑时切换到[t]装饰层[/t]，从而自定义模拟期间墨水的默认颜色，以实现电路美学的大幅度定制。\n\n既不是组件也不是迹线的墨水（如注释、填充和交叉）仅受[t]装饰层低[/t]的影响，因为这些墨水永远不处于激活状态。\n\n使用[t]选择工具[/t]，我们还可以将外部图像[t]拖放[/t]到[t]装饰层[/t]，应用在我们电路的顶部。",
  "编辑模式提示",
  "[t]1.[/t]熟悉阵列工具（及其功能），它是[t]虚拟面包板[/t]工具集中最多功能的工具，其次是选择工具。\n\n[t]2.[/t]查看游戏中包含的[t]样本项目[/t]，以获得灵感。\n\n[t]3.[/t]游戏每三分钟及进入模拟模式前会[t]自动保存[/t]。自动保存可以在[i]最近保存的项目[/i]菜单中加载。\n\n[t]4.[/t]铅笔工具允许您绘制粗线，但由于它会浪费建筑空间，因此应该节约使用。\n\n[t]5.[/t]使用可用的[t]快捷键[/t]。\n\n[t]6.[/t]可以通过右键单击墨水符号按钮来显示迹线的墨水符号。",
  "模拟模式提示",
  "[t]1.[/t]使用模拟控件来改变[t]模拟速度[/t]，暂停模拟并逐步前进模拟。\n\n[t]2.[/t]不要忘记在模拟期间可以使用鼠标[t]与锁存器交互[/t]。\n\n[t]3.[/t]密切关注电路编辑面板的事件日志卡，它会显示相关的编译和模拟警告。\n\n[t]4.[/t]在模拟期间，我们可以通过将鼠标悬停在迹线或组件上（启用[t]悬停高亮显示实体[/t]功能）来突出显示整个长度。该功能可以使用位于界面右上角的 \\\"火花\\\" 按钮\n\n",
  "虚拟设备",
  "在[t]虚拟面包板[/t]中，我们可以仅使用墨水构建许多东西，但某些项目可能具有特定要求，使其非常困难或无法使用迹线和组件复制，可能是由于尺寸限制、复杂性、性能或需要某种特殊行为。\n\n对于这些情况，我们有[t]虚拟设备[/t]，它们是专门的工具，可以构建更先进的电路。我们将在接下来的页面中详细介绍每个工具。",
  "虚拟内存 I",
  "虚拟内存 II",
  "虚拟显示",
  "[t]虚拟显示[/t]允许我们构建像素密度和颜色深度高于使用LED组件及其所需电路来驱动它们的屏幕。\n\n它具有[t]八种索引颜色模式[/t]，可根据[t]可定制调色板[/t]呈现图像，并且具有[t]RGB模式[/t]，可呈现1600万种颜色。几种模式使我们能够在颜色深度和内存占用之间选择最佳平衡。\n\n[t]VDisplay[/t]的分辨率可以是任何大小，只要它适合在板上，并且具有2¹⁸个像素或更少。此外，其缓冲指针在模拟期间可以进行修改。",
  "虚拟输入",
  "通过[t]虚拟输入[/t]，我们可以在模拟期间扩展与电路的交互范围，超越用鼠标切换锁存器。\n\n这个虚拟设备使得将现实生活中的[t]键盘[/t]输入直接绑定到电路板上的一组元件中成为可能。",
  "汇编",
  "[t]在[t]虚拟面包板[/t]中进行编程。",
  "概述",
  "基本元素",
  "语句 I",
  "表达式",
  "语句 II",
  "汇编器",
  "基本元素 - 数值",
  "基本元素 - 符号",
  "基本元素 - 指针",
  "基本元素 - 标签",
  "[t]标签[/t]也是内存地址的原语，但有一些关键差异：1. 它们指向其定义之后的[t]第一条指令[/t]；2. 它们[t]不能被取消定义[/t]；以及3. 它们具有[t]全局作用域[/t]，可以在其定义之前的语句中使用。标签可以用[t]@[/t]符号定义。\n\n[code][ca]\u003e[/ca] [cy]@[/cy] [cb]Sum[/cb]\n[ca]\u003e[/ca] [cv]lia[/cv] [cg]10[/cg][cy];[/cy] [cv]ldb[/cv] [cr]value[/cr][cy];[/cy] [cv]add[/cv]\n\n[ca]\u003e[/ca] [cy]@[/cy] [cb]MyOtherFunction[/cb]\n[ca]\u003e[/ca] [cv]psh[/cv][cy];[/cy] [cv]cal[/cv] [cb]Sum[/cb][cy];[/cy] [cv]ret[/cv] [ce]# “Sum” is an alias to lia 10’s VMem address.[/ce]",
  "回顾",
  "书签",
  "书签通过在汇编编辑器旁边添加标签的方式为我们提供了[t]快速导航[/t]到代码的方法，我们可以点击它们以转到它们被定义的行。汇编器会忽略书签，使用[t]bookmark[/t]和[t]sub_bookmark[/t]来声明它们。\n\n[code][ca]\u003e[/ca] [ca]bookmark[/ca] [cr]FunctionForSum[/cr] [ce]# Topic bookmark.[/ce]\n[ca]\u003e[/ca] [cv]lia[/cv] [cg]10[/cg][cy];[/cy] [cv]ldb[/cv] [cr]value[/cr][cy];[/cy] [cv]add[/cv]\n\n[ca]\u003e[/ca] [ca]sub_bookmark[/ca] [cr]PrintSumResult[/cr] [ce]# Subtopic bookmark.[/ce]\n[ca]\u003e[/ca] [cv]psh[/cv][cy];[/cy] [cv]cal[/cv] [cb]MyFunction[/cb][cy];[/cy] [cv]ret[/cv]",
  "外部编辑",
  "结论",
  "总结",
  "样本项目",
  "[t]虚拟面包板[/t]配备了[t]样本项目[/t]，展示了在游戏中可以构建的一些电路。例如，[i]32位计算机[/i]项目具有ALU，访问VMem的指令解码器以及滚动显示。\n\n可以通过界面右上角的[t]打开书本图标[/t]访问这些样本项目。",
  "图例 1 - 包含在示例项目中的32位计算机",
  "开发者说明",
  "附录",
  "附加信息",
  "蓝图规范",
  "虚拟面包板\n版权所有 (c) 2022-2023 Reverie Foundry。保留所有权利。\n\n翻译：Xeu\n仅供学习交流使用，禁止用于商业用途。\n\n使用Godot Engine制作。\n第三方许可证位于安装目录。",
  "启用虚拟显示",
  "编辑模式可见",
  "焦点视图",
  "将相机移动到显示器中心",
  "中心",
  "将相机移动到显示器左上角",
  "L",
  "将相机移动到显示器右下角",
  "R",
  "位置 XY",
  "分辨率 XY",
  "缩放 XY",
  "指向视频缓冲区的位置。\n\n如果设置为1024，虚拟显示将前往VMem中的地址1024，并使用存储在那里的值作为要渲染的图像的指针的位置。\n\n此行为使得通过将缓冲区位置（在本例中存储在地址1024处）更改为内存中包含不同图像数据的另一个位置，可以立即交换渲染的图像。",
  "地址",
  "每个VMem字用于像素数据的最大位数。\n\n虚拟显示将使用小于字大小的颜色深度的最大倍数作为每个字的像素数量。\n\n例如，如果颜色深度设置为3位，字大小设置为16，虚拟显示将使用字的最低15位（即5个像素）并忽略其余最高的17位。",
  "字大小",
  "颜色深度",
  "像素绘制的方向。两种模式都从虚拟显示的左上角向右下角渲染。\n\n水平 - 从左到右，从上到下绘制行。\n垂直 - 从上到下，从左到右绘制列。",
  "方向",
  "1位，来自调色板的2种颜色，\n每个VMem地址32像素\n以大端序排序。",
  "调色板",
  "黄色 - 最高有效位\n蓝色 - 最低有效位",
  "启用虚拟输入",
  "将相机移动到接口位",
  "将相机移动到最高有效位",
  "最高有效位",
  "将相机移动到最低有效位",
  "最低有效位",
  "位",
  "偏移 XY",
  "大小 XY",
  "按下 - 在输入键按下时处于活动状态。\n脉冲 - 仅在一个时钟周期内处于活动状态。",
  "模式",
  "键名",
  "点击以检查",
  "绑定使用换行符分隔，并使用以下语法定义：\n\n\u003ckey_name\u003e \u003d \u003cvalue\u003e\n\n绑定的值可以表示为数字（二进制、十进制、十六进制）或位列表：\n\n\\\"[3, 1]\\\" 等同于 \\\"0b1010\\\"。",
  "绑定",
  "Q \u003d 0x20\nW \u003d 16\nE \u003d [3]\nR \u003d 0x4\nT \u003d 0b10\nY \u003d 0b1",
  "启用VMem",
  "图例",
  "将相机移动到地址位",
  "将相机移动到内容位",
  "新建项目\n$fs_new_project",
  "打开项目\n$fs_open_project",
  "保存项目\n$fs_save_project",
  "另存项目",
  "项目名称",
  "撤销上一步操作",
  "重做上一步操作",
  "自动保存",
  "new_电路.虚拟面包板",
  "项目标题",
  "Virtual 电路 Board",
  "测试版本",
  "aaaaaaaaaaaaaaaaaaaaaa",
  "用户指南",
  "打开示例项目",
  "更新日志",
  "退出",
  "另存电路为",
  "切换左侧边栏\n$ui_toggle_left_sidebar",
  "打开项目",
  "保存项目",
  "仅编译板的可见部分。这对于查看电路中特定区域的统计数据很有用。",
  "切换游戏模式",
  "模拟",
  "上一步\n$sm_prev_update",
  "启动仿真时暂停",
  "暂停仿真\n$sm_pause_simulation",
  "下一步\n$sm_next_update",
  "在步进模式中前进的时钟周期数",
  "aaa",
  "目标仿真速度\n右键单击输入数值",
  "目标仿真速度\n右键单击使用滑块",
  "5000000",
  "使用装饰图层进行渲染",
  "365056 IPS",
  "高亮显示悬停实体",
  "允许虚拟输入使用绑定的按键\n捕捉键盘输入",
  "缩放时显示墨水符号。\n右键单击切换轨迹符号",
  "墨水符号叠加",
  "显示轨迹符号",
  "平面渲染",
  "切换汇编编辑器",
  "显示",
  "显示",
  "分辨率",
  "目标仿真频率",
  "位置",
  "缩放",
  "主要颜色",
  "背景颜色",
  "数字",
  "切换右侧边栏\n$ui_toggle_right_sidebar",
  "电路编辑器",
  "用户指南",
  "VMem设置",
  "笔记",
  "交换面板",
  "菜单标题",
  "最大化停靠",
  "菜单标题g",
  "Deselect All",
  "External Assembly",
  "The external assembly file\nmust have the same path\nas the project, ending with\nthe \\\".vcbasm\\\" extension.",
  "Import \u0026 Export",
  "Use the buttons below\nto copy data between\nthe project and the\nexternal assembly file.",
  "Embed Data",
  "Copy the vcbasm\u0027s data\nto the project\u0027s file and\ndisable external editing.",
  "Import ↓",
  "Export ↑",
  "Embed And Edit Locally",
  "Confirm",
  "[b]Blueprint Title[/b] \n\nThe example image we can see a simple connection between two components: The Latch at the top outputs its state to the yellow trace, because there’s a Write ink between the latch and the trace.\n\nThe Buffer at the bottom receives signals from the yellow trace as input, because there’s a Read ink between the trace and the Buffer.\n\n[b]Tags:[/b] Adder, 16-bit, Fast",
  "Blueprint Title \n\nThe example image we can see a simple connection between two components: The Latch at the top outputs its state to the yellow trace, because there’s a Write ink between the latch and the trace.\n\nThe Buffer at the bottom receives signals from the yellow trace as input, because there’s a Read ink between the trace and the Buffer.\n\nTags: Adder, 16-bit, Fast",
  "Paste blueprint into the board",
  "Copy blueprint to clipboard",
  "Edit blueprint",
  "Duplicate blueprint",
  "Delete blueprint",
  "Blueprint Title",
  "Edit Blueprint",
  "Name (32/32)",
  "Lorem Ipsum",
  "Description (512/512)",
  "Use commas to separate tags.",
  "Tags (16/16)",
  "Use the \\\"Update\\\" buttons to replace the circuit with the\ncurrent selection or the clipboard\u0027s blueprint\u0027s circuit.",
  "Circuit",
  "Update circuit with the current selection",
  "Update (selection)",
  "Update circuit with the clipboard\u0027s blueprint\u0027s circuit",
  "Update (clipboard)",
  "Search",
  "Tags",
  "125 Blueprints Found",
  "Toggle tags panel",
  "Create blueprint from selection",
  "Create blueprint from clipboard",
  "Create a blueprint from a circuit selection,\nor from a blueprint string in the clipboard",
  "New Blueprint",
  "Reload blueprints from disk",
  "Fill Adjacent Cells",
  "When enabled, the bucket tool will only fill areas that are directly\nadjacent or connected to the clicked cell. If disabled, all cells on\nthe board with the same ink or color will be painted.",
  "Pass Through Crosses",
  "When enabled, the bucket tool will pass through\nCross inks when filling connected cells.",
  "Pass Through Tunnels",
  "When enabled, the bucket tool will pass through\nTunnel inks when filling connected cells.",
  "Ignore Empty Areas",
  "When enabled, the bucket tool will not fill empty areas (None cells),\npreventing accidental filling of the entire board due to misclicks.",
  "Ink Color Fallback",
  "When this option is enabled and the decoration layers are being\nedited, if the clicked cell is not decorated (i.e. not painted over),\nthe bucket tool will instead use the cell\u0027s ink as the sample color.",
  "Multicolored Traces",
  "Tick",
  "102f",
  "VMem\u0027s state and address",
  "VMem",
  "0xfffff",
  "Actions",
  "Paste Empty Cells",
  "If enabled, the selection tool will include empty\n(None ink) cells when applying selections.",
  "Info",
  "LMB selects | RMB tiles",
  "Left-click a selection to move it around,\nor right-click it to start tiling.",
  "Drag and drop an image to insert it as a\nselection in the current layer.",
  "[t]VCB[/t] features a modular and customizable interface thanks to its [t]docking system[/t]. There are four docks in total, laid out in sidebars on both sides of the screen. Each dock can be set to display one of the [i]panels[/i] available in the game, like this [i]User Guide[/i]. Most panels however act like editors that allow us to work with specific aspects of our projects. They are:\n\n[t]Circuit Editor[/t] - contains the options related to editing the circuit board, like drawing, erasing, selecting, and others.\n[t]Assembly Editor[/t] - where we can write programs that will be available in the Virtual Memory during simulation.\n[t]Notes[/t] - a space dedicated for project documentation.\n[t]User Guide[/t] - the game\u0027s reference manual.\n[t]Blueprint Library[/t] - a convenient place for saving circuit blueprints.\n[t]VMem Settings[/t] - the menu that allows us to set the position of the VMem on the board.\n[t]VMem Editor[/t] - where we can edit and visualize the data stored in the Virtual Memory.\n[t]Virtual Display[/t] - contains all settings related to the VDisplay.\n[t]Virtual Input[/t] - the configuration panel for Virtual Input device.\n\nWe can swap a dock\u0027s panel by clicking on the icon on its top-left corner, beside the panel title.\n\nThe docks, as well as the sidebars, can also be resized and collapsed, allowing us to further adjust the interface.",
  "The Virtual Memory, or [t]VMem[/t] for short, has [t]2²⁰ addressable words of 4 bytes[/t]. This is a little over [t]one million rows of 32 bits[/t] to store up to 4 MiB of data, which should be enough to hold the most ambitious programs in [t]VCB[/t]. Note that we don’t have to use all the 32 bits available per word, e.g. when we are working with an 8-bit computer.\n\nCircuits can read and write to the [t]VMem[/t] using two sets of components that behave just like latches but have specific purposes: one set is used to write the [t]memory address[/t], and the other is used to read and write the [t]memory content[/t]. Those special components are placed by the game when the simulation is about to start, but we can configure their position while editing the circuit in the [t]VMem Settings[/t] menu. Circuits can access the Virtual Memory during simulation one address at a time, to [t]read or write[/t] data.\n\nIn the VMem Settings menu, we can also configure a memory region to be [i]preserved at the end of the simulation[/i]. Note that this simply results in a copy operation, so altering the persistent region [i]won\u0027t erase any existing data stored in the project\u0027s memory[/i].",
  "With the [t]VMem Editor[/t] panel we can conveniently [t]modify the values of the Virtual Memory\u0027s words[/t] when editing our projects.\n\nWords can be displayed in either [i]hexadecimal or binary[/i] format, which also affects how input is processed. If the display mode is set to [i]hexadecimal[/i] there\u0027s no need to add the [i]\\\"0x\\\"[/i] prefix when entering values. Similarly, if words are being shown in [i]binary[/i] we can directly input binary numbers without having to include [i]\\\"0b\\\"[/i]. In both cases we can also enter [i]decimal[/i] numbers by using the [i]\\\"0d\\\"[/i] prefix.\n\nNote that for advanced use cases it is also possible to edit the Virtual Memory [i]externally[/i].\n\nThe [i]VMem Editor[/i] not only allows us to adjust values in Edit mode but also serves as a [t]debugging tool during simulation[/t]. With it, we can follow the current address of the Virtual Memory, visualize the VMem\u0027s state (Red while [i]Locked[/i] and green when [i]Ready[/i]), and observe the changes to the words in real time.\n\n[t]External Editing Notes[/t]\n\n[t]-[/t] The external file must be manually created by the player.\n[t]-[/t] Since [t]VCB[/t] only reads the external file it must be manually copied/moved when the current project is saved/moved to another path.\n[t]-[/t] The external VMem file is read in big-endian order.",
  "Virtual Memory III",
  "[t]When interfacing with the VMem, you should be aware of:[/t]\n\n[t]Locking (2-tick access)[/t] - The VMem becomes [i]locked[/i] in the tick following an address change. While in this state, any input to its latches will be rejected and reported in the Event Log.\n\n[t]Content Precedence[/t] - If both address and content latches are toggled in the same tick, the content change will take precedence. That is to say, the current word will be modified first, and then the new word will be loaded.\n\n[cy][b]WARNING: VMem and Ripple-carry Counters[/b]\n\nPlain RCA counters [b]should not be used[/b] to increment the VMem\u0027s address latches. Their [i]\\\"rippling\\\"[/i] property causes latches to toggle at nearly every tick, which not only results in the [i]address jumping around[/i], but also in the [i]wrong address[/i] being set altogether, due to the VMem\u0027s locking behavior.[/cy]",
  "To simplify the process of creating programmable computers, [t]VCB[/t] implements a simple yet customizable [t]assembler[/t] that allows us to define our own instruction set.\n\nThe programs we write in the Assembly Editor are assembled into machine code and stored in the Virtual Memory.",
  "Assembly Language",
  "Before we start writing programs we must understand how the assembler translates the text we write into [t]machine code[/t]. To do so, the first concept we must get familiar with are [t]primitives[/t].\n\n[t]Primitives[/t] serve as the building blocks to write programs. They are the atomic pieces of information used by the assembler to populate the Virtual Memory.",
  "A primitive is a [t]number[/t] that can be either [t]literal[/t] (e.g. -5, 0b0001, 0xFF) or [t]non-literal[/t] (e.g. foo, bar, baz). Non-literal primitives are [t]aliases[/t] to their literal counterparts and need to be [t]defined[/t] in order to be used. Some of them can be undefined when not needed anymore, or redefined to alias another numeric literal. There are three types of non-literal primitives: Symbols, Pointers, and Labels.\n\nBefore we take a closer look at each type of primitive, let\u0027s first explore the structure of the assembly\u0027s syntax and understand where the primitives fit into it.",
  "The assembler parses code in [t]statements[/t] separated by [i]newlines[/i] or [i]semicolons[/i]. Statements can be either [t]directives[/t] or [t]instructions[/t].\n\n[t]Directives[/t] are actions or settings for the assembler itself. Among other things, they tell the assembler to define, redefine, and undefine non-literal primitives. Since directives are only commands and not data, [t]they are not translated into machine code[/t].\n\n[t]Instructions[/t] are [t]made of[/t] literal and non-literal primitives. Unlike directives, they are the actual [t]data[/t] composing our programs, and [t]will be converted into machine code[/t].\n\nWhen the machine code is being generated, all the primitives (numbers) in an instruction are bitwise [t]OR[/t]ed* together and stored in the VMem.\n\n*Unless an [i]expression[/i] is detected.",
  "We can [t]override the automatic ORing[/t] in instructions by using operators to form expressions. They allow us to perform bitwise and arithmetic operations with the primitives to determine how they will be evaluated before being stored in the VMem.\n\nExpressions are [i]restricted to instructions[/i] and cannot be used within directives. Note that with the exception of parentheses, operators [i]must have spaces separating them[/i]. All the supported operators are listed below.\n\n[b][cy]+[/cy][/b] Addition\n[b][cy]-[/cy][/b] Subtraction\n[b][cy]*[/cy][/b] Multiplication\n[b][cy]/[/cy][/b] Division\n[b][cy]%[/cy][/b] Modulo\n[b][cy]~[/cy][/b] Bitwise NOT\n[b][cy]\u0026[/cy][/b] Bitwise AND\n[b][cy]|[/cy][/b] Bitwise OR\n[b][cy]^[/cy][/b] Bitwise XOR\n[b][cy]\u003c\u003c[/cy][/b] Bit shifting left\n[b][cy]\u003e\u003e[/cy][/b] Bit shifting right\n[b][cy]([/cy][/b] Begin subexpression\n[b][cy])[/cy][/b] End subexpression",
  "[code][ca]\u003e[/ca] [cy]symbol[/cy] [cv]foo[/cv] [cg]0b0001[/cg]\n[ca]\u003e[/ca] [cv]foo[/cv] [cg]0b1000[/cg][cy];[/cy] [cg]0xF7[/cg][/code]\n\nIn the above example we have 3 statements, the first is a [t]directive[/t] and the two others are [t]instructions[/t]. The directive is just defining a primitive named [t]foo[/t], and it won’t be assembled into machine code as it does not contain any data.\n\nBut the following statement, [t]foo 0b1000[/t], does have primitives, two of them: it has the non-literal [t]foo[/t] (0b0001) defined earlier, and a numeric literal (0b1000). These two primitives will be [t]OR[/t]ed together to become a single instruction (0b1001) which will be stored in the Virtual Memory, followed by the third statement in the next address.",
  "When the game begins to translate instructions into machine code it [t]skips the first word[/t] of the Virtual Memory [i](address 0 is reserved and should not be used)[/i] and starts at address 1. The assembled data is stored in [t]big-endian order[/t] with negative values represented in [t]Two\u0027s Complement[/t].\n\nThe assembler ignores blank lines and comments in the code, which are indicated with a [t]#[/t] symbol.\n\n[code][ca]\u003e[/ca] [ce]# This is a comment.[/ce]\n[ca]\u003e[/ca] [cv]psh[/cv][cy];[/cy] [cv]cal[/cv] [cb]Print[/cb][cy];[/cy] [cv]ret[/cv] [ce]# Another comment.[/ce][/code]\n\nNow that we’ve learned about the assembly’s syntax and how instructions become machine code we can take a closer look into each type of [t]primitive[/t].",
  "[t]Numerics[/t] are the literal primitives. They can be expressed in base 10, hexadecimal, or binary (floating points are not supported), and must be no larger than 32 bits in order to fit into the words of the Virtual Memory.\n\n[code][ca]\u003e[/ca] [cg]10515545[/cg][cy];[/cy] [cg]-1[/cg][cy];[/cy] [cg]0xFFFF[/cg][cy];[/cy] [cg]0b01101010[/cg][/code]\n\nUnderscores can be used in numerics to improve their readability.\n\n[code][ca]\u003e[/ca] [cg]1_000_000[/cg][cy];[/cy] [cg]0b0000_1000[/cg][/code]",
  "[t]Symbols[/t] are the primitives for user-defined values, they are useful to create [t]mnemonics[/t] for opcodes. They must be defined with an [t]identifier[/t] followed by a [t]numeric literal[/t]. Optionally, symbols can also be redefined or undefined.\n\n[code][ca]\u003e[/ca] [cy]symbol[/cy] [cv]add[/cv] [cg]0xFF[/cg] [ce]# “add” from now on means “0xFF”.[/ce]\n[ca]\u003e[/ca] [cy]resymb[/cy] [cv]add[/cv] [cg]125[/cg]  [ce]# “add” from now on means “125”.[/ce]\n[ca]\u003e[/ca] [cy]unsymb[/cy] [cv]add[/cv]      [ce]# “add” is undefined.[/ce][/code]\n\nSymbols are highlighted in purple if they remain defined until the end of the program, otherwise they default to red.",
  "[t]Pointers[/t] are the primitives for memory addresses. Due to the pointer’s nature a statement that defines it is [t]both a directive and an instruction[/t]. A pointer can be defined with a [t]numeric literal[/t] address, or have one automatically assigned to it using the [i]inline[/i] keyword. Use [t]repoint[/t] and [t]unpoint[/t] to delimit its scope.\n\nIn the example below, we store the number [i]30[/i] at the address [i]0xFF[/i], which is now aliased to [i]\\\"foo\\\"[/i].\n\n[code][ca]\u003e[/ca] [cy]pointer[/cy] [cr]foo[/cr] [cg]0xFF 30[/cg][/code]\n\nIn this second case, we store the number [i]5[/i] between the previous and next instructions using the [i]inline[/i] keyword. The actual address will be automatically determined by the assembler.\n\n[code][ca]\u003e[/ca] [cy]pointer[/cy] [cr]bar[/cr] [cm]inline[/cm] [cg]5[/cg][/code]",
  "Before diving into more advanced features, let\u0027s take a moment to review what we have learned so far.\n\nWe write assembly code using [t]statements[/t] separated by [i]newlines[/i] or [i]semicolons[/i]. [t]Directive[/t] statements define the [t]primitives[/t] (numbers) that we use in [t]instruction[/t] statements, which are the actual [t]data[/t] of our programs.\n\nWhen generating the machine code, the assembler takes all the primitives in an instruction and [t]OR[/t]s them together, unless we form an expression using [t]operators[/t].\n\nThe [t]pointer[/t] primitive is special because its definition or redefinition is [t]both a directive and an instruction[/t]. The statement defining a pointer is stored in the specified address of the Virtual Memory, unless the [i]inline[/i] keyword is used.",
  "Origin Directive",
  "Using the [t]origin[/t] directive we can specify the memory address where the assembler should store the machine code generated for the subsequent instructions. This directive is particularly useful when we want to [i]store data separately[/i] from the program itself.\n\n[code][ca]\u003e[/ca] [ck]origin[/ck] [cg]0xFF00[/cg]\n[ca]\u003e[/ca] [cg]0b1010[/cg] [ce]# Stored at address 0xFF00.[/ce]\n[ca]\u003e[/ca] [cg]0b0101[/cg] [ce]# Stored at address 0xFF01.[/ce][/code]\n\nWe can also use the keyword [t]orgprev[/t] to revert the most recent origin directive, or [t]orgbase[/t] to revert them all. For the example below, consider that after translating some instructions to machine code, the assembler is at the address [i]0xA1[/i].\n\n[code][ca]\u003e[/ca] [ck]origin[/ck] [cg]0xB1[/cg]\n[ca]\u003e[/ca] [ck]origin[/ck] [cg]0xC1[/cg]\n[ca]\u003e[/ca] [ck]origin[/ck] [cg]0xD1[/cg]\n[ca]\u003e[/ca] [ck]origin[/ck] [cg]0xE1[/cg]\n[ca]\u003e[/ca] [ck]origin[/ck] [cm]orgprev[/cm] [ce]# Address set to 0xD1.[/ce]\n[ca]\u003e[/ca] [ck]origin[/ck] [cm]orgprev[/cm] [ce]# Address set to 0xC1.[/ce]\n[ca]\u003e[/ca] [ck]origin[/ck] [cm]orgbase[/cm] [ce]# Address set to 0xA1.[/ce][/code]",
  "Macros I",
  "[t]Macros[/t] allow us to improve the readability of our programs by abstracting the expressions required for complex instructions.\n\nLet\u0027s consider a hypothetical [t]mov[/t] instruction as an example. In this instruction, bits [7:4] determine the opcode, bits [3:2] represent the source register, and bits [1:0] indicate the destination register. Due to this instruction format, we can\u0027t rely on the assembler\u0027s automatic [i]OR[/i]ing, as we need to offset the position of the registers. To achieve this, we can use an expression that bitshifts the source register to the correct position and [i]OR[/i]s all the arguments together, as shown in the example below.\n\n[code][ca]\u003e[/ca] [cv]mov[/cv] [cy]|[/cy] [cv]rgA[/cv] [cy]\u003c\u003c[/cy] [cg]2[/cg] [cy]|[/cy] [cv]rgB[/cv]\n[ca]\u003e[/ca] [cv]mov[/cv] [cy]|[/cy] [cv]rgB[/cv] [cy]\u003c\u003c[/cy] [cg]2[/cg] [cy]|[/cy] [cv]rgA[/cv][/code]\n\nHowever, it would be very inconvenient to write long expressions like these for every instruction in our program. Let\u0027s see how we can avoid this scenario with the help of a [i]macro[/i].\n\n[code][ca]\u003e[/ca] [cn]macro[/cn] [co]mov[/co] [cy]{[/cy][cg]0b11000000[/cg] [cy]|[/cy] [cr]a[/cr][cy]? \u003c\u003c[/cy] [cg]2[/cg] [cy]|[/cy] [cr]b[/cr][cy]?}[/cy]\n[ca]\u003e[/ca] [co]mov[/co] [cv]rgA[/cv] [cv]rgB[/cv]\n[ca]\u003e[/ca] [co]mov[/co] [cv]rgB[/cv] [cv]rgA[/cv][/code]\n\nAs demonstrated above, thanks to [i]macros[/i], our instructions can be made simpler and more concise, allowing us to create longer and more complex programs without compromising readability.",
  "Macros II",
  "To define a macro we begin with the [t]macro[/t] keyword, followed by an [t]identifier[/t], and finally, the [t]body[/t] enclosed in curly braces. The macro\u0027s arguments are indicated with a [t]lowercase letter followed by a question mark[/t]. When the macro is expanded, every occurrence of the [i]\\\"a?\\\"[/i] placeholder will be replaced with the first argument, followed by the [i]\\\"b?\\\"[/i] placeholder for the second argument, and so on. Note that macros [t]cannot be chained/nested[/t], neither in their definition nor in their usage.\n\nLike symbols and pointers, macros can also be redefined and undefined, using the keywords [t]remac[/t] and [t]unmac[/t], respectively.\n\nError messages concerning macros can be distinguished by their color. Errors flagged by the assembler are presented in [i]red[/i], while the preprocessor highlights them in [i]orange[/i].",
  "If you would like to use an [t]external text editor[/t] to write the assembly code you may do so by enabling the respective option in the [i]External Editing[/i] button, located below the [i]Bookmarks[/i] icon in the [i]Assembly Editor[/i] panel. The game will then read the contents of a text file with the same name and path as the current project, ending with the [i]\\\".vcbasm\\\"[/i] extension.\n\n[t]External Editing Notes[/t]\n\n[t]-[/t] The external file must be manually created by the player.\n[t]-[/t] Since [t]VCB[/t] only reads the external file it must be manually copied/moved when the current project is saved/moved to another path.",
  "You should now have all the essential knowledge required to start playing with [t]Virtual Circuit Board[/t], but don’t forget to take a look at the included Sample Projects to see all the theory you’ve learned so far applied in practice.\n\nIf you need any help with [t]VCB[/t] feel free to reach me out in the game’s communities.\n\nI hope you have as much fun playing the game as I had developing it.\n\n\n[t]– Mause[/t]",
  "The details of the blueprint format can be found below.\n\n[t]Overview[/t]\n- Blueprints begin with the [i]\\\"VCB+\\\"[/i] prefix.\n- Data is encoded in Base64.\n- Bytes are in big-endian order.\n\n[t]Header[/t]\n3-byte blueprint version\n6-byte checksum (truncated SHA-1) of the remaining characters of the blueprint string\n4-byte width\n4-byte height\n\n[t]Layer Block(s)[/t]\n4-byte block size\n4-byte layer id (Logic \u003d 0, Deco On \u003d 1, Deco Off \u003d 2)\n4-byte uncompressed buffer size\nN-byte zstd-compressed RGBA8 buffer\n\n[t]Text Block(s)[/t]\n4-byte block size\n4-byte data id (Name \u003d 1024, Description \u003d 1025, Tags \u003d 1026)\n4-byte uncompressed buffer size\nN-byte zstd-compressed UTF-8 buffer\n\n[t]Notes[/t]\n- The Logic layer block must be present in all blueprints.\n- Decoration layer blocks are optional but if used both of them must be included.\n- All the text blocks are optional.\n\n[t]Legacy Blueprints[/t]\n- Blueprints created in early versions of VCB were encoded with a legacy format. They can be identified by the prefix [i]\\\"KLUv/\\\"[/i].",
  "External VMem",
  "The external VMem file\nmust have the same path\nas the project, ending with\nthe \\\".vcbmem\\\" extension.",
  "Copy the vcbmem\u0027s data\nto the project\u0027s file and\ndisable external editing.",
  "Hex",
  "0x00001",
  "Edit VMem externally",
  "Yellow - Most Significant Bits\nBlue - Least Significant Bits",
  "Address Latches",
  "Content Latches",
  "At the end of the simulation, the persistent section of the VMem will be\npreserved, either replacing the values manually set through the VMem\nEditor, or writing to the external VMem file (.vcbmem), if enabled.",
  "Persistent Memory",
  "First address (inclusive) of\nthe persistent memory range",
  "From",
  "Last address (inclusive) of\nthe persistent memory range",
  "To",
  "Open recent projects and autosaves",
  "Recent Projects",
  "Recent projects and autosaves\nwill be shown here.",
  "Autosaves",
  "Blueprint Library",
  "VMem Editor"
]