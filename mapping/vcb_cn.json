[
  "书签标题",
  "这是一个测试aaaaaaaaaaaaa",
  "全部展开/折叠",
  "关于",
  "虚拟电路板\n版权所有 © 2022-2023 Reverie Foundry。保留所有权利。\n\n翻译：Xeu\n仅供学习交流使用，禁止用于商业用途。\n\n使用Godot Engine制作。\n第三方许可证位于安装目录。",
  "关闭",
  "虚拟电路板的新功能",
  "虚拟电路板\n版权所有 © 2022 Reverie Foundry。保留所有权利。\n\n翻译：Xeu\n仅供学习交流使用，禁止用于商业用途。\n\n使用Godot Engine制作。\n第三方许可证位于安装目录。",
  "关闭",
  "您确定要退出吗？",
  "是",
  "否",
  "光敏性癫痫警告",
  "极少数人在接触某些视觉图像时可能会出现癫痫，包括可能出现在视频游戏中的闪烁灯光或图案。即使没有癫痫或癫痫病史，某些人可能有未被诊断出的疾病，在观看视频游戏时可能引起“光敏性癫痫发作”。\n\n这些癫痫发作可能会出现各种症状，包括头晕、视觉改变、眼睛或面部抽搐、胳膊或腿部的抽搐或颤动、迷失方向、困惑或暂时失去意识。癫痫发作还可能导致意识丧失或痉挛，从而造成摔倒或撞到附近物体而受伤。\n\n如果您出现任何这些症状，请立即停止游戏并咨询医生。家长应注意或询问他们的孩子是否出现上述症状。相较成年人，儿童和青少年更有可能出现这些癫痫发作。采取以下预防措施可降低光敏性癫痫发作的风险：在光线充足的房间中玩游戏；如果感到昏昏欲睡或疲劳，不要玩游戏。\n\n如果您或您的亲属有癫痫或癫痫病史，请在游戏前咨询医生。",
  "关闭",
  "设置",
  "窗口",
  "帧率限制器",
  "UI缩放",
  "1倍",
  "图形",
  "文本编辑器",
  "汇编字体大小",
  "笔记字体大小",
  "关闭",
  "快捷键",
  "操作",
  "按键或按钮",
  "操作名称",
  "关闭",
  "章节标题",
  "操作名称",
  "操作名称",
  "汇编编辑器",
  "绑定操作时，按\\\"Esc \\\"取消，按\\\"Backspace \\\"清除",
  "重置",
  "关闭",
  "放弃未保存的更改？",
  "保存",
  "放弃",
  "取消",
  "警告",
  "确定",
  "选项",
  "选项",
  "0",
  "使用外部汇编代码。\n外部汇编文件必须与项目路径相同，以 \\\".vcbasm\\\" 后缀结尾。",
  "强制重新加载",
  "无错误。",
  "L 1\nC 1",
  "图层",
  "图层逻辑",
  "工具",
  "游标信息",
  "悬停的墨水 ",
  "无",
  "位置 ",
  "X",
  "2000",
  "Y",
  "1024",
  "墨水",
  "空间优化",
  "追踪",
  "门",
  "反转门",
  "通用组件",
  "时钟间隔（时钟周期）",
  "LED调色板",
  "000000，ffffff，ff0000，00ff00，0000ff，ff0000，00ff00，0000ff，ff0000，00ff00，0000ff，ff0000，00ff00，0000ff，ff0000，00ff00",
  "0/16",
  "计时器间隔（毫秒）",
  "随机种子",
  "注释",
  "桶",
  "画笔",
  "大小",
  "8",
  "形状",
  "过滤器",
  "阵列",
  "重复",
  "1",
  "角度",
  "偏移",
  "X",
  "1",
  "Y",
  "空间Y",
  "1",
  "旋转",
  "自动交叉",
  "过滤器",
  "仿真",
  "鼠标交互模式",
  "切换",
  "按下",
  "统计信息",
  "视图",
  "绝对值",
  "默认",
  "单元格：123",
  "123",
  "实体：123",
  "选择",
  "删除",
  "变换",
  "旋转",
  "镜像",
  "蓝图字符串",
  "拖放",
  "装饰",
  "事件日志",
  "Tick 1026264\n达到断点：128，2040",
  "Tick 1026264\n达到断点：128，2040",
  "过滤器",
  "反转",
  "全部",
  "清除",
  "inpt",
  "全部",
  "无",
  "Lorem ipsum.",
  "无错误。",
  "L 1\nC 1",
  "流程控制 II",
  "在示例图像中，我们可以看到两个组件之间的简单连接：顶部的锁存器将其状态输出到黄色迹线，因为在锁存器和迹线之间有写入墨水。\n\n底部的缓冲器接收来自黄色迹线的信号作为输入，因为在迹线和缓冲器之间有读取墨水。\n\n在这个示例中，信号将从锁存器流向缓冲器，但反之不行。",
  "图像描述",
  "开始",
  "结束",
  "上一页",
  "下一页",
  "在本指南中，您将学习有关 [i]虚拟电路板[/i] 的所有必要知识。",
  "用户指南中的一些页面使用图像来辅助文本说明。这些图像有编号，并且可以称为 [i]图例[/i] 或 [i]电路图[/i]。[i]电路图[/i] 图像的右上角有一个按钮，我们可以点击它，将示例电路粘贴到电路板上进行仔细检查。",
  "关于[i]虚拟电路板[/i]的基础知识",
  "[t]虚拟电路板[/t]分为两个模式：编辑和模拟。\n\n在[t]编辑[/t]模式下，我们可以使用绘图工具修改电路，并使用组合编辑器编写程序。在[t]模拟[/t]模式下，我们可以看到电路运行并与之交互。\n\n我们可以通过点击游戏界面中模拟控制区域的[t]编辑/模拟[/t]按钮在编辑模式和模拟模式之间切换。\n\n进入模拟模式可能需要几秒钟，因为游戏需要[t]编译[/t]电路。",
  "[t]虚拟电路板[/t]配备了高性能的事件驱动[t]模拟引擎[/t]。\n\n这个模拟是[t]确定性的[/t]，这意味着给定的电路每次模拟时都会以完全相同的方式进行，不受任何随机因素影响其时序。\n\n由于是[t]事件驱动[/t]，该引擎仅处理电路的活动部分，使其每秒更新[t]数百万次[/t]，这取决于玩家的硬件配置。\n\n模拟的时钟频率（速度）可以轻松调整。模拟还可以暂停，并手动按给定的步骤前进。",
  "介绍游戏的用户界面",
  "[t]平移[/t]\n按住[i]鼠标中键[/i]并拖动鼠标可平移视图。或者，我们也可以使用箭头键来移动摄像机。\n\n[t]缩放[/t]\n旋转[i]鼠标滚轮[/i]上下滚动可进行缩放，或使用[i](=)[i]和[i](-)[/i]键。缩放与鼠标光标位置对齐。\n\n[i]注意：相机控制可以在快捷菜单中重新绑定。[/i]\n\n[t]快捷菜单[/t]\n游戏的快捷键列在[i]快捷菜单[/i]中，可以在其中重新映射它们。快捷菜单选项卡可通过界面右上角的选项菜单[i](齿轮图标)[/i]访问。",
  "[t]虚拟电路板[/t]通过[t]停靠系统[/t]实现模块化和可定制的界面。总共有四个停靠栏，分别位于屏幕的两侧边栏。每个停靠栏可以设置为显示游戏中可用的一个[i]面板[/i]，比如这个[i]用户指南[/i]。然而，大多数面板都像编辑器一样，允许我们处理项目的特定方面。它们包括：\n\n[t]电路编辑器[/t]- 包含与编辑电路板相关的选项，如绘制、擦除、选择等。\n[t]组合编辑器[/t]- 我们可以在模拟期间编写程序，这些程序将在虚拟内存中运行。\n[t]笔记[/t]- 专用于项目文档。\n[t]用户指南[/t]- 游戏的参考手册。\n[t]虚拟内存设置[/t]- 允许我们设置虚拟内存在电路板上的位置。\n[t]虚拟显示器[/t]- 包含与虚拟显示器相关的所有设置。\n\n我们可以通过点击停靠栏顶部左侧的图标（在面板标题旁边）来切换停靠栏的面板。\n\n停靠栏以及边栏都可以调整大小和折叠，使我们能够进一步调整界面。",
  "某些UI元素在右键单击时会展现[t]二次行为[/t]，例如控制模拟速度的滑块小部件，右键单击后将变为数字输入字段，以便精确控制时钟频率。\n\n可以通过鼠标悬停在具有替代操作的UI元素上来识别它们，它们的鼠标指针将显示为[i]加号和黄色颜色[/i]。",
  "[t]虚拟电路板[/t]中的电路工作原理。",
  "在[t]虚拟面包板[/t]中，我们通过在一个被称为[t]Board[/t]的方形画布上使用特定的颜色[t]墨水[/t]来构建电路。\n大多数墨水要么是[t]组件[/t]，比如逻辑门，要么是用于它们之间传递信号的[t]导线[/t]，但也有一些不是[t]实体[/t]的墨水，即它们不是需要模拟的逻辑对象。这些类型的墨水可以分为两组：[t]空间优化墨水[/t]（由可以压缩电路的墨水组成）和[t]注释墨水[/t]，它们只是静态墨水，不与其他任何墨水交互。\n在接下来的页面中，我们将学习有关组件和导线的所有知识；墨水 和实体之间的关系；实体之间的连接方式；以及可用的组件类型，包括它们的行为。然后，我们将介绍空间优化墨水，以及如何利用它们来构建紧凑的电路。",
  "[t]组件[/t]和[t]导线[/t]是[t]虚拟面包板[/t]电路的基础。\n[t]组件[/t]是设备，它们根据一个或多个外部输入来执行逻辑操作以改变它们的状态和输出。八种标准逻辑门都是 组件，但[t]虚拟面包板[/t]还实现了一些其他特殊的 组件。\n[t]导线[/t]是[t]虚拟面包板[/t]中 PCB 上印制的导线的等效物。导线传导信号，用于将组件连接到彼此。",
  "相同类型的 组件墨水在相邻绘制时将变成一个[t]单个实体[/t]。在 [i]电路 1[/i] 中，有 4 组 或门墨水，它们在模拟时将变成 4 个单独的 组件。\n我们可以看到实体可以拥有[t]任何形状或大小[/t]，只要它们的墨水是邻居关系。\n不同类型的组件墨水（如 OR 和 XOR）在放置在一起时不会合并。",
  "与组件不同，即使导线的墨水不完全相同，它们也会变成一个[t]单个实体[/t]，这是因为导线有 16 种颜色变体，除此之外还有两个特殊的线路墨水（Write 和 Read），用于指示连接应该在哪里进行以及信号流的方向。\n在下面的电路中有四条导线。它们都有流控制墨水（仍然属于导线），沿着它们散布。",
  "在[t]虚拟面包板[/t]中，当组件和导线并排放置时，它们不会自动连接，而是需要一个中间的墨水来指示信号流的方向，从而实现对信号传输的精细控制。\n用于流控制的墨水被称为 Write 和 Read。它们的名称是从组件的角度命名的，组件产生信号并将其写入导线，换句话说，它们在导线中[color=#e06666][b]写入Write[/b][/color] 它们的[color=#e06666][b]输出[/b][/color]。当信号到达目标位置时，组件会[color=#6fa8dc][b]读取Read[/b][/color] 它们的[color=#6fa8dc][b]输入[/b][/color]。请参考下面的例子：\n组件-> [color=#e06666][b]Write[/b][/color] ->线路-> [color=#6fa8dc][b]Read[/b][/color] -> 组件",
  "需要注意的是，[iw]Write[/iw] 和 [ir]Read[/ir]墨水仍然是导线，尽管它们具有连接的特殊行为。\n当 [iw]Write[/iw] 或 [ir]Read[/ir]墨水在线路的中间位置时，它们不会在线路的两侧创建连接，因为[t]连接只在导线和组件之间进行[/t]。\n在线路的中间使用 [iw]Write[/iw] 或 [ir]Read[/ir]墨水只是线路本身的另一部分，就像其他 16 种线路变体一样。",
  "在 [i]电路 1[/i] 中，我们可以看到两个组件之间的简单连接：顶部的锁存器输出其状态到黄色的 线路，因为在锁存器和线路之间有一个 [color=#e06666][b]Write[/b][/color]墨水。\n底部的 Buffer 从黄色的线路接收信号作为输入，因为在线路和 Buffer 之间有一个 [color=#6fa8dc][b]Read[/b][/color]墨水。",
  "流控制墨水必须直接与组件相接触，也就是说，一个 [color=#e06666][b]Write[/b][/color] 或 [color=#6fa8dc][b]Read[/b][/color]墨水的四个[t]立即相邻的单元格[/t]之一必须是 组件，以便与其形成连接。当我们开始使用空间优化墨水 时，这一点非常重要。",
  "组件可以[t]写出(Write)[/t]到导线，或者从导线[t]读入(Read)[/t]，或者[t]同时输入和输出[/t]，但它们[t]仅建立一次连接[/t]。这意味着它们要么连接（以三种可能的方式之一），要么不连接。\n换句话说，两个实体之间的连接是[t]不可计数的[/t]，无论它们有多少接触点或接触面积有多大。",
  "LED组件根据其激活的输入数量更改颜色。在 [i]电路 1[/i] 顶部的两个示例中，LED 的颜色相同，因为它们都只接收来自一个线路的信号。\n底部的 LEDs 有不同的颜色，因为它们都接收[t]3 个信号而不是一个[/t]。在左侧版本中，添加了两个其他导线，而在右侧版本中，信号先经过一个 Buffer，然后连接到 LED 的 3 个独立导线。",
  "组件和导线都支持[t]多输入和多输出连接[/t]，包括通常只有两个输入和一个输出的逻辑门。当有任何一个组件向导线写入时，导线就处于活动状态，实际上它们的行为类似于 OR 门。\n在下一页中，我们将看到游戏中每个门组件根据其输入的行为。然后我们将看看一般组件及其特殊行为。",
  "下面我们可以看到每个门根据其输入的行为。\nA = 活动输入数目，T = 总输入数目\n[t]BUFFER -[/t][i]A > 0[/i]\n[t]AND -[/t][i]A > 0 && A == T[/i]\n[t]OR -[/t][i]A > 0[/i]\n[t]XOR -[/t][i]A % 2（奇数个活动输入）[/i]\n\n[t]NOT -[/t][i]!BUFFER[/i]\n[t]NAND -[/t][i]!AND[/i]\n[t]NOR -[/t][i]!OR[/i]\n[t]XNOR -[/t][i]!XOR[/i]\n\n你可能已经注意到 Buffer 和 Or 门（以及它们的反向对应物）具有完全相同的行为，所以你可能会想为什么游戏中同时出现了它们两个。答案是[t]可读性[/t]。如果我们只使用 Buffer 来延迟信号并防止反流，我们可以使我们的电路更易于理解，同时将 Or 门保留在其预期的用例中。\n但是，如果我们抛开可读性，我们还可以利用组件的冗余性来进一步[t]压缩[/t]我们的电路，因为我们可以拥有两个\\\"或门\\\" 或两个 \\\"缓冲器\\\" 并排",
  "除了基本逻辑门外，[t]虚拟面包板[/t]还提供了几种[t]General 组件[/t]，它们使我们能够在电路中实现特殊的行为。现在我们来看看每个组件的功能。\n其中一些组件具有可以通过 [i]右键单击[/i]在 [i]电路 编辑面板[/i] 上更改的属性。这些属性是 [i]全局应用于所有实例[/i]的，即在板上的所有该组件实例上都适用。\n[t]锁存器 ON/OFF -[/t][i]在任何输入的上升沿上切换状态[/i]。\n在模拟中，我们可以使用鼠标与锁存器进行交互。有两种交互模式：切换模式（Toggle），使锁存器切换状态；和按压模式（Press），将保持锁存器处于激活状态，直到左键按下，或直到锁存器被其输入之一切换。锁存器有 ON 和 OFF 两个变种，它们的行为完全相同，只是在模拟开始时 ON 版本处于激活状态。\n[t]Clock -[/t][i]每 N 个 tick 切换一次[/i]。\n时钟间隔可以在右键菜单中调整。\n[t]LED -[/t][i]当活动输入数目 > 0 时激活[/i]。\n在模拟中，其颜色将与活动输入的数量匹配，最多为 15，可以在 LED 的右键菜单中自定义颜色，并应用于板上的所有 LED。",
  "[t]Timer -[/t][i]每 N 个实际毫秒切换一次[/i]。\n计时器间隔可以在右键菜单中调整。\n[t]Random -[/t][i]在任何输入的上升沿上随机切换[/i]。\n默认情况下，组件使用唯一的基于时间的种子，但是可以在右键菜单中禁用，并改为使用用户定义的种子。\n[t]Breakpoint -[/t][i]当活动输入数目 > 0 时激活[/i]。\n在其自身状态的上升沿上触发断点（不是其输入的上升沿），这将暂停模拟并在事件日志中报告事件。\n[t]Wireless (0 to 3) -[/t][i]当活动输入数目 > 0 时激活[/i]。\n这四种无线墨水的行为都像一个全局连接的 Or 门。",
  "到目前为止，我们已经学会了使用多种[t]线路和组件墨水[/t]来创建[t]虚拟面包板[/t]中的电路的基础知识，这已经足够构建一些非常简单的电路了。然而，很快我们会发现受到板上二维空间的物理限制，最大的挑战是如何在其他导线阻挡的情况下使用导线来连接不同的 组件。\n这就是[t]空间优化墨水[/t]发挥作用的地方，它们给了我们在[t]虚拟面包板[/t]中创建紧凑电路所需的自由。在接下来的页面中，我们将看看这个组中的每个墨水，从最基础的交叉开始。但首先，你应该知道：\n[t]1.[/t]尽管使用空间优化墨水与导线更常见，但它们与组件[i]使用方式相同[/i]。\n[t]2.[/t]除了 Bus 外，空间优化墨水[i]在并排放置时不会相互作用[/i]，需要在它们之间放置线路、组件或 bus。",
  "[t]交叉 Cross墨水[/t]可以放置在导线或组件[t]交叉点[/t]的中心位置，以允许它们在相互交叉时独立存在。交叉墨水只能有一个像素宽，并且必须至少相隔一个像素，即不能连接成链状或堆叠。\n在 [i]电路 1[/i] 顶部的两个示例中，我们可以看到有效使用 交叉墨水来防止垂直和水平实体在交叉时合并。底部两个示例展示了 交叉墨水的无效用法。\n不要忘记 交叉墨水也可以与 组件（如逻辑门）一起使用，如 [i]电路 2[/i] 中所示。",
  "[t]隧道 Tunnel[/t]的行为与 交叉墨水类似，但是基于[t]入口和出口对应[/t]的概念，这些点可以放置得更远。\n例如，触碰一个 隧道墨水的逻辑门、线路或 bus（入口）的左侧将连接到离入口右侧最近的具有相同类型墨水的第一个 隧道（出口），在入口和出口之间的空间中可以是任何东西，甚至可以是其他类型的墨水，如[t]不同墨水的其他隧道[/t]，如 [i]电路 1[/i] 中所示。",
  "[t]Mesh[/t]是与 Wireless墨水相似的更多功能替代品。它与 隧道 类似，允许触碰 meshes 的导线、buses 和组件在板上[t]不同位置[/t]上合并在一起。",
  "[t]总线 Bus[/t]墨水允许多个门和导线[t]通过相同的空间[/t]，板上有 6 种颜色变种的 Bus，就像不同颜色的导线一样，在接触时也会合并在一起。",
  "最后，[t]虚拟面包板[/t]还提供了一些不与电路交互的墨水，但可用于美观或文档目的：\n[t]注释[/t]- 用于在板上绘制注释。\n[t]填充[/t]- 用于填充电路中墨水之间的空白空间，因此它也可以涂在装饰层上。\n装饰层和填充层的墨水行为相同，可以互换使用，上述描述只是建议的用法。这两种相似的墨水存在的原因是可以使用绘图工具的 过滤器 选项仅删除其中一种而保留另一种。\n为方便起见，该类别中还提供了[t]None[/t]墨水（即空白空间），在过滤器中使用时最有用，只限制绘制到空白区域。",
  "在[t]虚拟面包板[/t]中构建电路。",
  "[t]虚拟面包板[/t]拥有多种绘图工具，使构建电路成为一项轻松的任务，它们包括：\n\n[t]阵列工具[/t]- 一个高度可定制的工具，可以同时绘制多个像素。\n[t]铅笔工具[/t]- 使用大画笔绘制。\n[t]橡皮擦工具[/t]- 从板上擦除像素。\n[t]颜色拾取工具[/t]- 选择一种墨水使其成为活动墨水。\n[t]选择工具[/t]- 移动、复制、粘贴、复制等。\n[t]填充工具[/t]- 用相同颜色填充区域。\n\n某些工具还有一些特殊功能，比如[t]过滤器[/t]。",
  "[t]阵列工具[/t]是游戏中最多功能的工具。它旨在使[t]绘制多条迹线[/t]或均匀间隔的元件更加容易。\n\n在工具选项中，我们可以更改同时绘制的像素数量，以及它们的间距和角度。我们还可以启用非常方便的[t]自动交叉[/t]选项，该选项会在我们在非空间上绘制时自动放置[t]交叉墨水[/t]。\n\n在绘制时按住[t]Shift[/t]键可以激活[t]轴约束[/t]，使直线绘制更容易。",
  "[t]过滤器[/t]是阵列工具、铅笔工具和橡皮擦工具的一项功能，它允许我们指定要覆盖的墨水。\n\n这使得轻松更改迹线的颜色而不影响周围的颜色变得非常容易。它还使我们能够在不小心覆盖其他东西的情况下，专门在空白区域绘制。",
  "[t]蓝图[/t]是一种简单的方法，可以在不必发送整个项目文件的情况下与他人共享我们电路的小部分。它们通过将电路的选定部分复制到[t]文本剪贴板[/t]中，然后我们可以按照希望与他人共享的方式分享这些剪贴板内容。逆向过程同样简单，只需要将文本复制到剪贴板，然后点击按钮将蓝图粘贴回电路板。\n\n[t]Blueprint[/t]功能通过[t]选择工具[/t]获得。\n\n[i]注意：蓝图规范在用户指南的附录章节中提供。[/i]",
  "当游戏处于模拟模式时，组件和迹线墨水的颜色将与编辑器中的颜色不同，以表示它们的激活状态。当实体（例如组件或迹线）处于[t]ON[/t]状态时，墨水将具有鲜艳的颜色，而[t]OFF[/t]状态时墨水将呈深色。\n\n但是，我们可以在编辑时切换到[t]装饰层[/t]，从而自定义模拟期间墨水的默认颜色，以实现电路美学的大幅度定制。\n\n既不是组件也不是迹线的墨水（如注释、填充和交叉）仅受[t]装饰层低[/t]的影响，因为这些墨水永远不处于激活状态。\n\n使用[t]选择工具[/t]，我们还可以将外部图像[t]拖放[/t]到[t]装饰层[/t]，应用在我们电路的顶部。",
  "[t]1.[/t]熟悉阵列工具（及其功能），它是[t]虚拟面包板[/t]工具集中最多功能的工具，其次是选择工具。\n\n[t]2.[/t]查看游戏中包含的[t]样本项目[/t]，以获得灵感。\n\n[t]3.[/t]游戏每三分钟及进入模拟模式前会[t]自动保存[/t]。自动保存可以在[i]最近保存的项目[/i]菜单中加载。\n\n[t]4.[/t]铅笔工具允许您绘制粗线，但由于它会浪费建筑空间，因此应该节约使用。\n\n[t]5.[/t]使用可用的[t]快捷键[/t]。\n\n[t]6.[/t]可以通过右键单击墨水符号按钮来显示迹线的墨水符号。",
  "[t]1.[/t]使用模拟控件来改变[t]模拟速度[/t]，暂停模拟并逐步前进模拟。\n\n[t]2.[/t]不要忘记在模拟期间可以使用鼠标[t]与锁存器交互[/t]。\n\n[t]3.[/t]密切关注电路编辑面板的事件日志卡，它会显示相关的编译和模拟警告。\n\n[t]4.[/t]在模拟期间，我们可以通过将鼠标悬停在迹线或组件上（启用[t]悬停高亮显示实体[/t]功能）来突出显示整个长度。该功能可以使用位于界面右上角的 \\\"火花\\\" 按钮\n\n",
  "在[t]虚拟面包板[/t]中，我们可以仅使用墨水构建许多东西，但某些项目可能具有特定要求，使其非常困难或无法使用迹线和组件复制，可能是由于尺寸限制、复杂性、性能或需要某种特殊行为。\n\n对于这些情况，我们有[t]虚拟设备[/t]，它们是专门的工具，可以构建更先进的电路。我们将在接下来的页面中详细介绍每个工具。",
  "虚拟内存，或称为[t]VMem[/t]，拥有[t]2²⁰个可寻址的4字节字[/t]。这大约相当于[t]100万行32位[/t]，可存储最多[t]4 MiB[/t]的数据，对于[t]虚拟面包板[/t]中最具野心的程序来说应该足够了。注意，我们不必使用每个字中可用的所有32位，例如，在使用8位计算机时。\n\n电路可以使用两组像锁存器一样工作的组件来读写[t]VMem[/t]：一组用于写入[t]内存地址[/t]，另一组用于读取和写入[t]内存内容[/t]。这些特殊组件是在模拟即将开始时由游戏放置的，但是在[t]VMem设置[/t]菜单中编辑电路时可以配置它们的位置。电路可以在模拟期间每次访问一个地址，以[t]读取或写入[/t]数据。",
  "当与[t]VMem[/t]进行交互时，应遵循以下三条准则：\n\n[t]1.[/t]可以在同一周期内更改[t]相同类型[/t]（地址或内容）的多个VMem锁存器。\n\n[t]2.[/t]地址锁存器和内容锁存器不应在同一周期内更改，否则会导致未定义的行为。\n\n[t]3.[/t]VMem将在地址更改后的下一个周期中获取内存内容（即更改地址需要2个周期），在此期间地址锁存器和内容锁存器将[t]不会[/t]响应信号。这意味着不应该在每个周期切换地址锁存器。\n\n[t]关于锁定锁存器和串联进位计数器[/t]\n\n如果您观察到每隔一个[i]地址锁存器[/i]的奇怪行为似乎不起作用，则意味着在执行准则[t]3[/t]的时候可能发生了意外违规，最有可能的原因是使用串联进位计数器来递增VMem地址。由于这种类型的计数器通常在每个周期切换其位，因此在VMem中使用时不适合没有某种缓冲电路的情况。\n\n另一种替代方法是用[t]同步进位前瞻计数器[/t]替换串联进位计数器，该计数器可以在同一周期中设置所有的[i]地址锁存器[/i]。",
  "[t]虚拟显示[/t]允许我们构建像素密度和颜色深度高于使用LED组件及其所需电路来驱动它们的屏幕。\n\n它具有[t]八种索引颜色模式[/t]，可根据[t]可定制调色板[/t]呈现图像，并且具有[t]RGB模式[/t]，可呈现1600万种颜色。几种模式使我们能够在颜色深度和内存占用之间选择最佳平衡。\n\n[t]VDisplay[/t]的分辨率可以是任何大小，只要它适合在板上，并且具有2¹⁸个像素或更少。此外，其缓冲指针在模拟期间可以进行修改。",
  "通过[t]Virtual Input[/t]，我们可以在模拟期间扩展与电路的交互范围，超越用鼠标切换锁存器。\n\n这个虚拟设备使得将现实生活中的[t]键盘[/t]输入直接绑定到电路板上的一组元件中成为可能。",
  "[t]在[t]虚拟面包板[/t]中进行编程。",
  "为了使可编程计算机的创建更加简单，[t]虚拟面包板[/t]实现了[t]汇编器[/t]。\n\n在汇编编辑器中编写的程序将被汇编成机器码并存储在虚拟内存中。",
  "在我们开始编写程序之前，我们必须了解游戏是如何将我们编写的文本汇编成[t]机器码[/t]的。为此，我们必须首先熟悉[t]原语[/t]这个概念。\n\n对于我们来说，[t]原语[/t]是编写程序的基本构建块；而对于汇编器来说，它们是用于填充虚拟内存的原子信息。",
  "原语是一个[t]数字[/t]，可以是[t]字面值[/t]（例如 -5、0b0001、0xFF）或[t]非字面值[/t]（例如 foo、bar、baz）。非字面值原语是它们字面值对应项的别名，并且需要在使用前进行[t]定义[/t]。其中一些原语在不再需要时可以未定义，或重新定义为别的数字字面值的别名。有三种类型的非字面值原语：符号、指针和标签。\n\n在我们更详细地查看每种类型的原语之前，让我们了解一下汇编语法的结构以及原语的位置。",
  "[t]虚拟面包板[/t]通过 [i]换行符[/i] 或 [i]分号[/i] 来汇编代码中的[t]语句[/t]。它们可以是[t]指令[/t]或[t]伪指令[/t]：\n\n->[t]伪指令[/t]用于告诉汇编器定义、重新定义和取消定义非字面值原语，但请注意它们[t]不包含[/t]原语本身。\n\n->[t]指令[/t]是由在伪指令中定义的字面值和非字面值原语组成的，它们是程序的实际[t]数据[/t]。\n\n在汇编过程中，指令中的所有原语（数字）都将被进行位[t]或[/t]运算，然后存储在虚拟内存的一个地址中。\n\n除非检测到一个 [i]表达式[/i]。",
  "我们可以通过使用运算符来形成表达式，从而覆盖指令中自动进行的[t]或[/t]运算。它们允许我们对原语执行位和算术运算，以确定在存储在虚拟内存之前它们将如何被计算。\n\n表达式只能在指令中使用，不能在伪指令中使用。运算符之间必须有空格，除了括号 [b][cy]()[/cy][/b]。可用的运算符有：\n\n[b][cy]+[/cy][/b] 加法\n[b][cy]-[/cy][/b] 减法\n[b][cy][/cy][/b] 乘法\n[b][cy]/[/cy][/b] 除法\n[b][cy]%[/cy][/b] 取模\n[b][cy]~[/cy][/b] 按位非\n[b][cy]&[/cy][/b] 按位与\n[b][cy]|[/cy][/b] 按位或\n[b][cy]^[/cy][/b] 按位异或\n[b][cy]<<[/cy][/b] 位左移\n[b][cy]>>[/cy][/b] 位右移\n[b][cy]([/cy][/b] 开始子表达式\n[b][cy])[/cy][/b] 结束子表达式",
  "[code][ca]>[/ca] [cy]符号[/cy] [cv]foo[/cv] [cg]0b0001[/cg]\n[ca]>[/ca] [cv]foo[/cv] [cg]0b1000[/cg][cy];[/cy] [cg]0xF7[/cg][/code]\n\n在上面的例子中，有三个语句，第一个是[t]伪指令[/t]，而后两个是[t]指令[/t]。该伪指令仅定义了一个名为[t]foo[/t]的原语，因为它不包含任何数据，所以不会被汇编成机器码。\n\n但是接下来的语句[t]foo 0b1000[/t]包含原语，其中有两个原语：它有先前定义的非字面值原语[t]foo[/t](0b0001)，以及一个数字字面值 (0b1000)。这两个原语将被[t]或[/t]运算合并成一个单独的指令 (0b1001)，然后存储在虚拟内存中，紧随其后的是下一个地址中的第三个语句。",
  "当游戏开始将指令汇编成机器码时，它会跳过虚拟内存的第一个单词（地址0已保留，不应使用），从地址1开始。组装后的数据以[t]大端序[/t]存储，并用[t]二进制补码[/t]表示负值。\n\n汇编器会忽略代码中的空行和注释，注释用[t]#[/t]符号表示。\n\n[code][ca]>[/ca] [ce]# 这是一条注释。[/ce]\n[ca]>[/ca] [cv]psh[/cv][cy];[/cy] [cv]cal[/cv] [cb]Print[/cb][cy];[/cy] [cv]ret[/cv] [ce]# 另一条注释。[/ce][/code]\n\n现在，我们已经了解了汇编语法以及指令如何成为机器码，我们可以更仔细地研究每种[t]原语[/t]类型。",
  "[t]数字[/t]是字面原语。它们必须在32位范围内，以适应虚拟内存的单词。\n\n[code][ca]>[/ca] [ce]# 支持十进制、十六进制和二进制。[/ce]\n[ca]>[/ca] [cg]10515545[/cg][cy];[/cy] [cg]0xFFFF[/cg][cy];[/cy] [cg]0b01101010[/cg] [ce]# 负数也可以。[/ce][/code]\n\n[code][ca]>[/ca] [ce]# 不支持浮点数。[/ce]\n[ca]>[/ca] [cg]3.14[/cg][cy];[/cy] [cg]2.71[/cg][cy];[/cy] [cg]0.333333[/cg] [/code]\n\n可以在数字中使用下划线以提高可读性。",
  "[t]符号[/t]是用户定义值的原语，它们有助于为操作码创建[t]助记符[/t]。它们必须用[t]标识符[/t]后跟[t]数字字面值[/t]来定义。可以选择重新定义或取消定义。\n\n[code][ca]>[/ca] [cy]符号[/cy] [cv]add[/cv] [cg]0xFF[/cg] [ce]# 定义：“add” 从现在开始表示 “0xFF”。[/ce]\n[ca]>[/ca] [cy]符号[/cy] [cv]add[/cv] [cg]125[/cg] [ce]# 重新定义：“add” 从现在开始表示 “125”。[/ce]\n[ca]>[/ca] [cy]符号[/cy] [cv]add[/cv] [ce]# 取消定义：“add” 不再存在。[/ce][/code]\n\n如果符号在代码结束时没有被取消定义，它们将显示为紫色，否则它们默认为红色。",
  "[t]指针[/t]是内存地址的原语。由于指针的性质，定义它的语句[t]既是指令又是指令[/t]。指针可以用[t]数字字面值[/t]来定义，或者使用 [i]inline[/i] 关键字自动分配一个地址。对于前者，指针将存储在指定的地址中，而不是在上一条语句之后。\n\n[code][ca]>[/ca] [ce]# 将数字30放入地址0xFF，现在别名为 “foo”。[/ce]\n[ca]>[/ca] [cy]指针[/cy] [cr]foo[/cr] [cg]0xFF 30[/cg] [ce]# 地址必须是字面原语。[/ce]\n[ca]>[/ca] [ce]# 在上一条和下一条指令之间放入数字5。[/ce]\n[ca]>[/ca] [cy]指针[/cy] [cr]bar[/cr] [co]inline[/co] [cg]5[/cg] [ce]# “bar” 现在指向未知地址。[/ce][/code]",
  "[t]标签[/t]也是内存地址的原语，但有一些关键差异：1. 它们指向其定义之后的[t]第一条指令[/t]；2. 它们[t]不能被取消定义[/t]；以及3. 它们具有[t]全局作用域[/t]，可以在其定义之前的语句中使用。标签可以用[t]@[/t]符号定义。\n\n[code][ca]>[/ca] [cy]@[/cy] [cb]Sum[/cb]\n[ca]>[/ca] [cv]lia[/cv] [cg]10[/cg][cy];[/cy] [cv]ldb[/cv] [cr]value[/cr][cy];[/cy] [cv]add[/cv]\n\n[ca]>[/ca] [cy]@[/cy] [cb]MyOtherFunction[/cb]\n[ca]>[/ca] [cv]psh[/cv][cy];[/cy] [cv]cal[/cv] [cb]Sum[/cb][cy];[/cy] [cv]ret[/cv] [ce]# “Sum” 是指向 lia 10 的虚拟内存地址的别名。[/ce]",
  "我们使用[t]语句[/t]编写汇编代码，语句之间用 [i]换行符[/i] 或 [i]分号[/i] 分隔。[t]指令[/t]语句定义了我们程序的实际[t]数据[/t]，其中包含的所有原语进行[t]或[/t]运算，除非我们使用运算符构成表达式。得到的数字随后放入虚拟内存中，在上一条汇编指令之后的下一个地址。\n\n由于指针的性质，定义或重新定义指针的语句既是[t]指令又是指令[/t]。定义指针的语句将放入虚拟内存的指定地址，除非使用 [i]inline[/i] 关键字。",
  "书签通过在汇编编辑器旁边添加标签的方式为我们提供了[t]快速导航[/t]到代码的方法，我们可以点击它们以转到它们被定义的行。汇编器会忽略书签，使用[t]bookmark[/t]和[t]sub_bookmark[/t]来声明它们。\n\n[code][ca]>[/ca] [ca]bookmark[/ca] [cr]FunctionForSum[/cr] [ce]# 主题书签。[/ce]\n[ca]>[/ca] [cv]lia[/cv] [cg]10[/cg][cy];[/cy] [cv]ldb[/cv] [cr]value[/cr][cy];[/cy] [cv]add[/cv]\n\n[ca]>[/ca] [ca]sub_bookmark[/ca] [cr]PrintSumResult[/cr] [ce]# 子主题书签。[/ce]\n[ca]>[/ca] [cv]psh[/cv][cy];[/cy] [cv]cal[/cv] [cb]MyFunction[/cb][cy];[/cy] [cv]ret[/cv]",
  "如果您想使用[t]外部文本编辑器[/t]编写汇编代码，可以在 [i]外部编辑[/i] 菜单中启用相应选项，该菜单位于 [i]汇编编辑器[/i] 面板中的 [i]书签[/i] 图标下方。然后，游戏将读取与当前项目同名和路径的文本文件，以 [i]\\\".vcbasm\\\"[/i] 后缀结尾。在[i]外部编辑[/i]菜单中，您还可以选择启用[i]外部基本VMem[/i]设置，该设置将在每次模拟开始时将[t]外部二进制文件[/t]的内容复制到VMem中。与外部程序集文件类似，VMem文件也应与当前项目共享相同的名称和路径，但以[i]\\\".虚拟面包板mem\\\"[/i]扩展名结尾。\n\n[t]注释[/t]\n\n[t]-[/t]启用外部程序集或VMem选项后，必须手动创建相应的文件。\n\n[t]-[/t]由于[t]虚拟面包板[/t]只读取外部程序集和VMem文件，因此在将当前项目保存/移动到其他路径时，必须手动复制/移动这些文件。\n\n[t]-[/t]外部VMem文件以big-endian顺序读取。“，",
  "总结。",
  "[t]虚拟面包板[/t]配备了[t]样本项目[/t]，展示了在游戏中可以构建的一些电路。例如，[i]32位计算机[/i]项目具有ALU，访问VMem的指令解码器以及滚动显示。\n\n可以通过界面右上角的[t]打开书本图标[/t]访问这些样本项目。",
  "现在，你应该掌握了开始使用[t]虚拟面包板[/t]所需的所有基本知识，但不要忘记查看附带的样本项目，以在实践中应用你学到的所有理论。\n\n如果你在使用[t]虚拟面包板[/t]的过程中需要任何帮助，请随时在游戏社区中联系我。\n\n希望你在玩游戏时能和我在开发游戏时一样开心！\n\n\n[t]– Mause[/t]",
  "附加信息",
  "本页面描述了当前的蓝图格式，此格式在0.2版本中引入。在先前的[t]虚拟面包板[/t]版本中生成的旧版蓝图以[i]\\\"KLUv/\\\"[/i]开头。新的蓝图以[i]\\\"虚拟面包板+\\\"[/i]开头。\n\n蓝图使用Base64编码。字节按大端序排列。\n\n[t]标头[/t]\n3字节蓝图标识符（虚拟面包板+）\n3字节蓝图版本\n6字节蓝图字符串剩余字符的校验和（截断SHA-1）\n4字节宽度\n4字节高度\n\n[t]层块[/t]\n4字节块大小\n4字节层id（Logic=0，Deco-On=1，Deco-Off=2）\n4个字节未压缩缓冲区大小\nN字节zstd压缩RGBA8缓冲区\n\n逻辑层块必须为出现在所有蓝图中。\n\n装饰层块是可选的，但如果使用，则必须同时包含这两个块。",
  "虚拟面包板\n版权所有 (c) 2022-2023 Reverie Foundry。保留所有权利。\n\n翻译：Xeu\n仅供学习交流使用，禁止用于商业用途。\n\n使用Godot Engine制作。\n第三方许可证位于安装目录。",
  "设置",
  "焦点视图",
  "中心",
  "L",
  "R",
  "位置 XY",
  "分辨率 XY",
  "缩放 XY",
  "地址",
  "字大小",
  "颜色深度",
  "方向",
  "概述",
  "1位，来自调色板的2种颜色，\n每个VMem地址32像素\n以大端序排序。",
  "调色板",
  "000000，ffffff，ff0000，00ff00，0000ff，ff0000，00ff00，0000ff，ff0000，00ff00，0000ff，ff0000，00ff00，0000ff，ff0000，00ff00",
  "黄色 - 最高有效位\n蓝色 - 最低有效位",
  "错误状态",
  "设置",
  "焦点视图",
  "全部",
  "最高有效位",
  "最低有效位",
  "位",
  "地址",
  "位置 XY",
  "偏移 XY",
  "大小 XY",
  "模式",
  "键名",
  "点击以检查",
  "绑定",
  "Q = 0x20\nW = 16\nE = [3]\nR = 0x4\nT = 0b10\nY = 0b1",
  "黄色 - 最高有效位\n蓝色 - 最低有效位",
  "错误状态",
  "地址",
  "焦点视图",
  "全部",
  "最高有效位",
  "最低有效位",
  "位",
  "位置 XY",
  "偏移 XY",
  "大小 XY",
  "内容",
  "焦点视图",
  "全部",
  "最高有效位",
  "最低有效位",
  "位",
  "位置 XY",
  "偏移 XY",
  "大小 XY",
  "图例",
  "黄色 - 最高有效位\n蓝色 - 最低有效位",
  "最近保存",
  "项目名称",
  "自动保存",
  "项目标题",
  "Virtual 电路 Board",
  "aaaaaaaaaaaaaaaaaaaaaa",
  "样本项目",
  "项目名称",
  "选项",
  "全屏",
  "设置",
  "快捷键",
  "更新日志",
  "关于",
  "退出",
  "模拟",
  "模拟",
  "aaa",
  "5000000",
  "365056 IPS",
  "墨水符号叠加",
  "显示",
  "分辨率",
  "位置",
  "缩放",
  "显示",
  "主要颜色",
  "背景颜色",
  "数字",
  "位置",
  "缩放",
  "菜单标题",
  "菜单标题g",
  "菜单标题",
  "关闭",
  "保存",
  "不再显示此警告",
  "全屏",
  "无边框",
  "垂直同步",
  "网格",
  "发光",
  "动态背景",
  "切换书签",
  "外部程序集和虚拟内存",
  "从与项目相同路径的文本文件中加载程序集，文件以 \\\".vcbasm\\\" 结尾",
  "在外部编辑程序集",
  "从与项目相同路径的二进制文件中加载虚拟内存，文件以 \\\".虚拟面包板mem\\\" 结尾",
  "使用外部基础虚拟内存",
  "持久虚拟内存",
  "跟随虚拟内存地址",
  "层逻辑",
  "高层装饰",
  "低层装饰",
  "橡皮擦工具",
  "撤销\n$ed_undo",
  "重做\n$ed_redo",
  "绘图工具",
  "阵列工具\n$ed_tool_阵列工具",
  "铅笔工具\n$ed_tool_铅笔工具",
  "橡皮擦工具\n$ed_tool_橡皮擦工具",
  "颜色拾取工具（Alt）",
  "选择工具\n$ed_tool_selection",
  "填充工具\n$ed_tool_bucket",
  "交叉\n$ed_阵列工具_交叉",
  "隧道",
  "网格",
  "总线（右键单击更改颜色）",
  "写入\n$ed_阵列工具_Write",
  "读取\n$ed_阵列工具_read",
  "导线（右键单击更改颜色）",
  "缓冲区",
  "与",
  "或",
  "异或",
  "非",
  "与非",
  "或非",
  "异或非",
  "锁存器 ON",
  "锁存器 OFF",
  "时钟",
  "LED",
  "计时器",
  "随机",
  "使用时间作为种子",
  "断点",
  "无线（右键单击更改频道）",
  "注释",
  "填充器",
  "无",
  "相邻",
  "方形画笔形状",
  "菱形画笔形状",
  "圆形画笔形状",
  "过滤器",
  "更改角度\n$ed_阵列工具_rotate_right",
  "自动交叉切换\n$ed_阵列工具_toggle_auto交叉",
  "轴约束角度",
  "轴约束切换",
  "在按下鼠标按钮时切换锁存器状态",
  "在按下鼠标按钮时将锁存器状态设置为开，并在释放按钮时立即设置为关",
  "切换值的视图模式：绝对值，百分比。",
  "切换顺序的视图模式：默认（电路编辑器顺序），降序，升序。",
  "绘制的总区域。不包括带有注释和填充器的单元格。",
  "电路中唯一导线和组件的总数。",
  "复制选择",
  "粘贴选择",
  "选择重复",
  "删除选定内容",
  "应用选定内容",
  "向左旋转选定内容",
  "向右旋转选定内容",
  "水平镜像选定内容",
  "垂直镜像选定内容",
  "将选定内容复制为文本到剪贴板",
  "从剪贴板文本粘贴选定内容",
  "复制和粘贴蓝图时包含装饰图层",
  "拖放图像以将其作为当前图层中的选定内容插入",
  "保存电路",
  "目录",
  "将此电路粘贴到电路板中",
  "切换目录",
  "用户指南",
  "图例和电路",
  "图例 1 - 虚拟面包板启动屏幕",
  "电路 1 - 入门电路",
  "介绍",
  "编辑和模拟",
  "模拟引擎",
  "用户界面",
  "导航和快捷键",
  "停靠系统",
  "右键单击行为",
  "虚拟电路",
  "基于绘图的界面",
  "组件和导线",
  "墨水和实体 I",
  "电路 1 - 相邻的墨水合并为一个实体",
  "墨水和实体 II",
  "电路 1 - 不同颜色的导线将合并在一起",
  "流程控制 I",
  "流程控制 II",
  "电路 1 - 由三种颜色变体组成的单一导线，以及特殊的追写和追读墨水",
  "流程控制 III",
  "电路 1 - 在此示例中，信号将从锁存器流向缓冲器，但反之则不行",
  "流程控制 IV",
  "不可计数连接 I",
  "不可计数连接 II",
  "电路 1 - LED的颜色会根据活动输入的数量而改变",
  "电路 2 - 另一个使用XOR门的例子",
  "多重输入输出",
  "门电路组件",
  "通用组件I",
  "通用组件II",
  "空间优化",
  "交叉墨水",
  "电路 1 - 顶部是有效的交叉放置方式，底部是无效的",
  "电路 2 - 一个连接到三根导线的AND门",
  "隧道墨水",
  "电路 1 - 不同颜色的导线通过隧道",
  "网格墨水",
  "电路 1 - 通过网格进行远程连接的导线",
  "总线墨水",
  "电路 1 - 多个实体可以使用总线通过相同的单元",
  "注释墨水",
  "编辑",
  "工具",
  "阵列工具",
  "蓝图",
  "图层",
  "编辑模式提示",
  "模拟模式提示",
  "虚拟设备",
  "虚拟内存 I",
  "虚拟内存 II",
  "虚拟显示",
  "虚拟输入",
  "组合",
  "概述",
  "汇编语言",
  "基本元素",
  "语句 I",
  "表达式",
  "语句 II",
  "汇编器",
  "基本元素 - 数值",
  "基本元素 - 符号",
  "基本元素 - 指针",
  "基本元素 - 标签",
  "回顾",
  "书签",
  "外部编辑",
  "结论",
  "示例项目",
  "图例 1 - 包含在示例项目中的32位计算机",
  "开发者说明",
  "附录",
  "蓝图规范",
  "关于",
  "启用虚拟显示",
  "编辑模式可见",
  "将相机移动到显示器中心",
  "将相机移动到显示器左上角",
  "将相机移动到显示器右下角",
  "指向视频缓冲区的位置。\n\n如果设置为1024，虚拟显示将前往VMem中的地址1024，并使用存储在那里的值作为要渲染的图像的指针的位置。\n\n此行为使得通过将缓冲区位置（在本例中存储在地址1024处）更改为内存中包含不同图像数据的另一个位置，可以立即交换渲染的图像。",
  "每个VMem字用于像素数据的最大位数。\n\n虚拟显示将使用小于字大小的颜色深度的最大倍数作为每个字的像素数量。\n\n例如，如果颜色深度设置为3位，字大小设置为16，虚拟显示将使用字的最低15位（即5个像素）并忽略其余最高的17位。",
  "像素绘制的方向。两种模式都从虚拟显示的左上角向右下角渲染。\n\n水平 - 从左到右，从上到下绘制行。\n垂直 - 从上到下，从左到右绘制列。",
  "启用虚拟输入",
  "将相机移动到接口位",
  "将相机移动到最高有效位",
  "将相机移动到最低有效位",
  "按下 - 在输入键按下时处于活动状态。\n脉冲 - 仅在一个时钟周期内处于活动状态。",
  "绑定使用换行符分隔，并使用以下语法定义：\n\n<key_name> = <value>\n\n绑定的值可以表示为数字（二进制、十进制、十六进制）或位列表：\n\n\\\"[3, 1]\\\" 等同于 \\\"0b1010\\\"。",
  "启用VMem",
  "将相机移动到地址位",
  "将相机移动到内容位",
  "新建项目\n$fs_new_project",
  "打开项目\n$fs_open_project",
  "保存项目\n$fs_save_project",
  "另存项目",
  "打开最近保存和自动保存的项目",
  "撤销上一步操作",
  "重做上一步操作",
  "new_电路.虚拟面包板",
  "测试版本",
  "用户指南",
  "打开示例项目",
  "选项",
  "另存电路为",
  "切换左侧边栏\n$ui_toggle_left_sidebar",
  "打开项目",
  "保存项目",
  "仅编译板的可见部分。这对于查看电路中特定区域的统计数据很有用。",
  "切换游戏模式",
  "上一步\n$sm_prev_update",
  "启动仿真时暂停",
  "暂停仿真\n$sm_pause_simulation",
  "下一步\n$sm_next_update",
  "在步进模式中前进的时钟周期数",
  "目标仿真速度\n右键单击输入数值",
  "目标仿真速度\n右键单击使用滑块",
  "使用装饰图层进行渲染",
  "高亮显示悬停实体",
  "允许虚拟输入使用绑定的按键\n捕捉键盘输入",
  "缩放时显示墨水符号。\n右键单击切换轨迹符号",
  "显示轨迹符号",
  "平面渲染",
  "切换汇编编辑器",
  "显示",
  "目标仿真频率",
  "切换右侧边栏\n$ui_toggle_right_sidebar",
  "电路编辑器",
  "汇编编辑器",
  "笔记",
  "用户指南",
  "VMem设置",
  "交换面板",
  "最大化停靠",
  "用户指南"
]