[
    "Bookmarks Title",
    "This is a testaaaaaaaaaaaaa",
    "Expand/Collapse All",
    "Deselect All",
    "About",
    "Virtual Circuit Board\nCopyright (c) 2022-2024 Reverie Foundry. All rights reserved.\n\nMade with Godot Engine.\nThird-party licenses are available at the installation directory.",
    "Close",
    "New in Virtual Circuit Board",
    "Virtual Circuit Board\nCopyright (c) 2022 Reverie Foundry. All rights reserved.\n\nMade with Godot Engine.\nThird-party licenses are available at the installation directory.",
    "Save",
    "Are you sure you want to quit?",
    "Yes",
    "No",
    "Photosensitive Seizure Warning",
    "        A very small percentage of people may experience a seizure when exposed to certain visual images, including flashing lights or patterns that may appear in video games. Even people who have no history of seizures or epilepsy may have an undiagnosed condition that can cause these “photosensitive epileptic seizures” while watching video games.\n\n        These seizures may have a variety of symptoms, including lightheadedness, altered vision, eye or face twitching, jerking or shaking of arms or legs, disorientation, confusion, or momentary loss of awareness. Seizures may also cause loss of consciousness or convulsions that can lead to injury from falling down or striking nearby objects.\n\n        Immediately stop playing and consult a doctor if you experience any of these symptoms. Parents should watch for or ask their children about the above symptoms. Children and teenagers are more likely than adults to experience these seizures. The risk of photosensitive epileptic seizures may be reduced by taking the following precautions: Play in a well-lit room; Do not play if you are drowsy or fatigued.\n\n    If you or any of your relatives have a history of seizures or epilepsy, consult a doctor before playing.",
    "Do not show this warning again",
    "Settings",
    "Window",
    "Fullscreen",
    "Borderless",
    "V-Sync",
    "Framerate Limiter",
    "UI Scale",
    "1x",
    "Graphics",
    "Grid",
    "Glow",
    "Dynamic Background",
    "Text Editors",
    "Assembly Font Size",
    "Notes Font Size",
    "Shortcuts",
    "Action",
    "Key or Button",
    "Action Name",
    "Section Title",
    "Assembly Editor",
    "When binding an action press \\\"Esc\\\" to cancel, and \\\"Backspace\\\" to clear.",
    "Reset",
    "Discard unsaved changes?",
    "Discard",
    "Cancel",
    "Warning",
    "Ok",
    "Option",
    "0",
    "External Assembly",
    "The external assembly file\nmust have the same path\nas the project, ending with\nthe \\\".vcbasm\\\" extension.",
    "Import & Export",
    "Use the buttons below\nto copy data between\nthe project and the\nexternal assembly file.",
    "Embed Data",
    "Copy the vcbasm's data\nto the project's file and\ndisable external editing.",
    "Import ↓",
    "Export ↑",
    "Embed And Edit Locally",
    "Confirm",
    "Toggle bookmarks",
    "Edit assembly externally",
    "Load the assembly from a text file with the same path as the project, ending with \\\".vcbasm\\\"",
    "Load the VMem from a binary file with the same path as the project, ending with \\\".vcbmem\\\"",
    "Use external base VMem",
    "Persistent VMem",
    "External assembly and VMem",
    "Follow VMem Address",
    "No errors.",
    "L 1\nC 1",
    "[b]Blueprint Title[/b] \n\nThe example image we can see a simple connection between two components: The Latch at the top outputs its state to the yellow trace, because there’s a Write ink between the latch and the trace.\n\nThe Buffer at the bottom receives signals from the yellow trace as input, because there’s a Read ink between the trace and the Buffer.\n\n[b]Tags:[/b] Adder, 16-bit, Fast",
    "Blueprint Title \n\nThe example image we can see a simple connection between two components: The Latch at the top outputs its state to the yellow trace, because there’s a Write ink between the latch and the trace.\n\nThe Buffer at the bottom receives signals from the yellow trace as input, because there’s a Read ink between the trace and the Buffer.\n\nTags: Adder, 16-bit, Fast",
    "Paste blueprint into the board",
    "Copy blueprint to clipboard",
    "Edit blueprint",
    "Duplicate blueprint",
    "Delete blueprint",
    "Delete",
    "Blueprint Title",
    "Edit Blueprint",
    "Name (32/32)",
    "Lorem Ipsum",
    "Description (512/512)",
    "Use commas to separate tags.",
    "Tags (16/16)",
    "Use the \\\"Update\\\" buttons to replace the circuit with the\ncurrent selection or the clipboard's blueprint's circuit.",
    "Circuit",
    "Update circuit with the current selection",
    "Update (selection)",
    "Update circuit with the clipboard's blueprint's circuit",
    "Update (clipboard)",
    "Error status",
    "Search",
    "Tags",
    "125 Blueprints Found",
    "Prev",
    "Next",
    "Toggle tags panel",
    "Create blueprint from selection",
    "Create blueprint from clipboard",
    "Create a blueprint from a circuit selection,\nor from a blueprint string in the clipboard",
    "New Blueprint",
    "Reload blueprints from disk",
    "Layers",
    "Layer Logic",
    "Layer Decoration High",
    "Layer Decoration Low",
    "Eraser tool",
    "Undo\n$ed_undo",
    "Redo\n$ed_redo",
    "Tools",
    "Draw tool",
    "Array tool\n$ed_tool_array",
    "Pencil tool\n$ed_tool_pencil",
    "Eraser tool\n$ed_tool_eraser",
    "Color picker tool (Alt)",
    "Selection tool\n$ed_tool_selection",
    "Bucket tool\n$ed_tool_bucket",
    "Cursor Info",
    "Hovered Ink  ",
    "None",
    "Position     ",
    "X",
    "2000",
    "Y",
    "1024",
    "Inks",
    "Space Optimization",
    "Cross\n$ed_array_cross",
    "Tunnel",
    "Mesh",
    "Bus (right-click to change color)",
    "Traces",
    "Write\n$ed_array_write",
    "Read\n$ed_array_read",
    "Trace (right-click to change color)",
    "Gates",
    "Buffer",
    "And",
    "Or",
    "Xor",
    "Inverted Gates",
    "Not",
    "Nand",
    "Nor",
    "Xnor",
    "General Components",
    "Latch ON",
    "Latch OFF",
    "Clock",
    "Clock Interval (ticks)",
    "LED",
    "LED Palette",
    "000000, ffffff, ff0000, 00ff00, 0000ff, ff0000, 00ff00, 0000ff, ff0000, 00ff00, 0000ff, ff0000, 00ff00, 0000ff, ff0000, 00ff00",
    "0/16",
    "Timer",
    "Timer Interval (msec)",
    "Random",
    "Random Seed",
    "Use time as seed",
    "Breakpoint",
    "Wireless (right-click to change channel)",
    "Annotation",
    "Filler",
    "Bucket",
    "Fill Adjacent Cells",
    "When enabled, the bucket tool will only fill areas that are directly\nadjacent or connected to the clicked cell. If disabled, all cells on\nthe board with the same ink or color will be painted.",
    "Pass Through Crosses",
    "When enabled, the bucket tool will pass through\nCross inks when filling connected cells.",
    "Pass Through Tunnels",
    "When enabled, the bucket tool will pass through\nTunnel inks when filling connected cells.",
    "Ignore Empty Areas",
    "When enabled, the bucket tool will not fill empty areas (None cells),\npreventing accidental filling of the entire board due to misclicks.",
    "Ink Color Fallback",
    "When this option is enabled and the decoration layers are being\nedited, if the clicked cell is not decorated (i.e. not painted over),\nthe bucket tool will instead use the cell's ink as the sample color.",
    "Brush",
    "Size",
    "8",
    "Shape",
    "Square brush shape",
    "Diamond brush shape",
    "Circle brush shape",
    "Filter",
    "Array",
    "Repeat",
    "1",
    "Angle",
    "Change angle\n$ed_array_rotate_right",
    "Offset",
    "Space Y",
    "Auto-cross toggle\n$ed_array_toggle_autocross",
    "Rotate",
    "Axis constraint angle",
    "Axis constraint toggle",
    "Auto-cross",
    "Multicolored Traces",
    "Simulation",
    "Tick",
    "102f",
    "VMem's state and address",
    "VMem",
    "0xfffff",
    "Mouse Interaction Mode",
    "Toggles the latch when the mouse button is pressed",
    "Toggle",
    "Sets the latch's state to ON when the mouse button is pressed\nand immediately sets to OFF when the button is released",
    "Press",
    "Statistics",
    "View",
    "Toggle view mode for values:\nAbsolute, Percentage.",
    "Abs",
    "Toggle view mode for order:\nDefault (Circuit Editor order),\nDescending, Ascending.",
    "Default",
    "Total area drawn. Excluding cells\nwith Annotation and Filler inks.",
    "Cells: 123",
    "123",
    "Total amount of unique traces\nand components in the circuit.",
    "Entities: 123",
    "Selection",
    "Actions",
    "Copy selection",
    "Paste selection",
    "Duplicate selection",
    "Delete selection",
    "Apply selection",
    "Transform",
    "Rotate selection left",
    "Rotate selection right",
    "Mirror",
    "Mirror selection horizontally",
    "Mirror selection vertically",
    "Blueprint String",
    "Copy selection as text to clipboard",
    "Paste selection from clipboard text",
    "Include decoration layers when\ncopying and pasting blueprints",
    "Options",
    "Paste Empty Cells",
    "If enabled, the selection tool will include empty\n(None ink) cells when applying selections.",
    "Info",
    "LMB selects | RMB tiles",
    "Left-click a selection to move it around,\nor right-click it to start tiling.",
    "Drag & Drop",
    "Drag and drop an image to insert it as a\nselection in the current layer.",
    "Decoration",
    "Event Log",
    "Tick 1026264\nBreakpoint reached at 128, 2040",
    "Invert",
    "All",
    "Clear",
    "Save circuit",
    "inpt",
    "Lorem ipsum.",
    "Contents",
    "Flow control II",
    "In the example image we can see a simple connection between two components: The Latch at the top outputs its state to the yellow trace, because there’s a Write ink between the latch and the trace.\n\nThe Buffer at the bottom receives signals from the yellow trace as input, because there’s a Read ink between the trace and the Buffer.\n\nIn this example signals will flow from the Latch to the Buffer, but not the opposite.",
    "Paste this circuit into the board",
    "Description of the Image",
    "Toggle table of contents",
    "Start",
    "End",
    "The User Guide",
    "In this guide you will learn everything you need to get started with [i]Virtual Circuit Board[/i].",
    "Figures and circuits",
    "Some pages in the User Guide make usage of images to assist with the text explanation. These images are numbered and may be refered as either [i]figures[/i] or [i]circuits[/i]. The [i]circuit[/i] images feature a button at their top-right corner that allows us to paste the example circuit into the board so we can closely inspect it.\n\nTake a look at the [i]Figure 1[/i] and the [i]Circuit 1[/i].",
    "Figure 1 - VCB splash screen.",
    "Circuit 1 - Introduction circuit.",
    "Introduction",
    "The basics about [i]Virtual Circuit Board[/i].",
    "Editing and simulating",
    "[t]VCB[/t] is separated in two modes, edit and simulation.\n\nWhile [t]editing[/t] we can use the drawing tools to modify our circuit, and the assembly editor to write programs. And during [t]simulation[/t] we can see our circuit running and interact with it.\n\nWe can alternate between edit and simulation mode by clicking the [t]Edit/Simulate[/t] button in the simulation controls section of the game’s interface.\n\nEntering simulation mode may take a few seconds while the game [t]compiles[/t] the circuit.",
    "Simulation engine",
    "[t]VCB[/t] features a high-performant event-driven [t]simulation engine[/t].\n\nThe simulation is [t]deterministic[/t], which means that a given circuit will be simulated identically every time without any sort of randomness affecting its timings.\n\nBy being [t]event-driven[/t] the engine only processes active parts of circuits, allowing it to run at up to [t]millions[/t] of updates per second, depending on the player’s hardware.\n\nThe tickrate (speed) of the simulation can be easily adjusted. The simulation can also be paused and manually advanced by a given amount of steps.\n",
    "User Interface",
    "Navigating the game's UI.",
    "Navigation and shortcuts",
    "[t]Pan[/t]\nHold [i]MMB (Middle Mouse Button)[/i] and drag the mouse to pan the view. Alternatively we can also use the arrow keys to move the camera.\n\n[t]Zoom[/t]\nRotate the [i]mouse wheel[/i] up/down to zoom in/out, or use the [i](=)[/i] and [i](-)[/i] keys. Zooming is aligned with the mouse cursor position.\n\n[i]Note: the camera controls can be rebinded in the Shortcuts menu.[/i]\n\n[t]Shortcuts[/t]\nThe game’s shortcuts are listed in the [i]Shortcuts menu[/i], where they can be remapped. The Shortcuts tab is accessible through the options menu on the top-right corner of the UI [i](gear icon)[/i].",
    "Docking System",
    "[t]VCB[/t] features a modular and customizable interface thanks to its [t]docking system[/t]. There are four docks in total, laid out in sidebars on both sides of the screen. Each dock can be set to display one of the [i]panels[/i] available in the game, like this [i]User Guide[/i]. Most panels however act like editors that allow us to work with specific aspects of our projects. They are:\n\n[t]Circuit Editor[/t] - contains the options related to editing the circuit board, like drawing, erasing, selecting, and others.\n[t]Assembly Editor[/t] - where we can write programs that will be available in the Virtual Memory during simulation.\n[t]Notes[/t] - a space dedicated for project documentation.\n[t]User Guide[/t] - the game's reference manual.\n[t]Blueprint Library[/t] - a convenient place for saving circuit blueprints.\n[t]VMem Settings[/t] - the menu that allows us to set the position of the VMem on the board.\n[t]VMem Editor[/t] - where we can edit and visualize the data stored in the Virtual Memory.\n[t]Virtual Display[/t] - contains all settings related to the VDisplay.\n[t]Virtual Input[/t] - the configuration panel for Virtual Input device.\n\nWe can swap a dock's panel by clicking on the icon on its top-left corner, beside the panel title.\n\nThe docks, as well as the sidebars, can also be resized and collapsed, allowing us to further adjust the interface.",
    "Right-click behavior",
    "Some UI elements exhibit a [t]secondary behavior when right-clicked[/t], the slider widget that controls the simulation speed for example, will turn into a numerical input field for precise control of the tickrate. \n\nThe UI elements with alternative actions can be spotted by the change of the mouse cursor when it passes over them, it will display a [i]plus sign and an yellow color[/i].",
    "Virtual Circuits",
    "How circuits work in [t]VCB[/t].",
    "Drawing-based Interface",
    "In [t]VCB[/t] we build circuits by drawing in a square canvas referred as [t]Board[/t] using specific colors called [t]Inks[/t].\n\nThe majority of inks are either [t]Components[/t] like logic gates, or the [t]Traces[/t] used to carry signals between them, but there is also inks that are not [t]Entities[/t], i.e. which are not logical objects that get simulated. Those kind of inks are divided in two groups: [t]Space Optimization[/t], composed of inks that allow us to compact our circuits, and [t]Annotation[/t], which are simply static inks that do not interact with any others.\n\nIn the next pages we’ll learn all about components and traces; the relation between inks and entities; how the connection between entities works; and the types of components available, including how each one of them behaves. Then we'll take a look at the Space Optimization inks, and how we can take advantage of them to build compact circuits.",
    "Components and Traces",
    "[t]Components[/t] and [t]traces[/t] are the foundation of circuits in [t]VCB[/t].\n\n[t]Components[/t] are devices that perform logic operations to change their state and output, usually based on one or more external inputs. The eight standard logic gates are all components, but [t]VCB[/t] also implements some special others.\n\n[t]Traces[/t] (wires) are [t]VCB[/t]’s equivalent of the traces/tracks printed in PCBs. Traces conduct signals and are used to connect components to one another.",
    "Inks and Entities I",
    "Component inks of the same type will turn into a [t]single entity[/t] when drawn side by side (left and right, or up and down). In [i]Circuit 1[/i] there are 4 groups of OR Gate inks, which will become 4 individual components during simulation. \n\nAs we can see entities can have [t]any kind of shape or size[/t] as long as their inks are neighbors.\n\nDifferent component inks (e.g. OR & XOR) won’t be merged when placed side by side.",
    "Circuit 1 - Adjacent inks become a single entity.",
    "Inks and Entities II",
    "Different from the components, traces will turn into a single entity [t]even when they are not all the same ink[/t], this is because traces have 16 color variations, in addition to other two special trace inks (Write and Read) that indicate where connections should be made and the direction of signal flow.\n\nIn the circuit below there are four traces. They all have the flow control inks (which are still part of the traces) scattered along them.",
    "Circuit 1 - Traces of different colors will merge together.",
    "Flow control I",
    "In [t]VCB[/t] components and traces do not automatically connect to each other when placed side by side, instead they require an intermediate ink that dictates the direction of signal flow, which allows a fine control over signal transmission.\n\nThe inks used for flow control are called Write and Read. They are named from the point of view of components, which generate signals to be send across traces, in other words, they [color=#e06666][b]write[/b][/color] their [color=#e06666][b]output[/b][/color] into traces. When signals arrive at their destinations the components [color=#6fa8dc][b]read[/b][/color] them to their [color=#6fa8dc][b]inputs[/b][/color]. See the example below.\n\nComponent -> [color=#e06666][b]Write[/b][/color] -> Trace -> [color=#6fa8dc][b]Read[/b][/color] -> Component",
    "It is important to keep in mind that the [iw]Write[/iw] and [ir]Read[/ir] inks are still traces, despite their special behavior of making connections.\n\nWhen [iw]Write[/iw] or [ir]Read[/ir] inks are used in the middle of a trace they do not create a connection between the two sides of the trace since [t]connections are only made between traces and components[/t].\n\nA [iw]Write[/iw] or [ir]Read[/ir] ink in the middle of a trace is merely another part of the trace itself, just like any of the 16 trace variants.",
    "Circuit 1 - A single trace made out of three color variants, as well as the special trace inks, Write and Read.",
    "Flow control III",
    "In the [i]Circuit 1[/i] we can see a simple connection between two components: The Latch at the top outputs its state to the yellow trace, because there’s a [color=#e06666][b]Write[/b][/color] ink between the latch and the trace.\n\nThe Buffer at the bottom receives signals from the yellow trace as input, because there’s a [color=#6fa8dc][b]Read[/b][/color] ink between the trace and the Buffer.",
    "Circuit 1 - In this example signals will flow from the Latch to the Buffer, but not the opposite.",
    "Flow control IV",
    "The flow control inks must be in direct contact with components, that is, a [color=#e06666][b]Write[/b][/color] or [color=#6fa8dc][b]Read[/b][/color] ink should have a component as one of its four [t]immediatly neighbor cells[/t] in order to form a connection with it.\n\nThis is important to keep in mind when we start to work with the Space Optimization inks.",
    "Uncountable connection I",
    "Components can [t]write[/t] to traces, [t]read[/t] from them, or [t]both[/t], but their connection is [t]only made once[/t]. This means that they are either connected (in any of the three possible ways) or they are not. \n\nIn other words the connection between two entities is [t]not countable[/t], regardless of how many points of contact they have or how large the contact area is.",
    "Uncountable connection II",
    "The LED component changes colors based on its amount of active inputs. In the two examples at the top of the [i]Circuit 1[/i] the LEDs have the same color because both of them are only receiving a signal [t]from one trace[/t].\n\nThe LEDs at the bottom have a different color because both are receiving [t]3 signals instead of one[/t]. In the left version two other traces were added, and in the right the signal from the trace was first passed to a Buffer, and from it 3 individual traces were connected to the LED. ",
    "Circuit 1 - LEDs change color based on the amount of active inputs.",
    "Circuit 2 - Another example, using XOR gates.",
    "Multiple IO",
    "Both components and traces support [t]multiple input and output connections[/t], including the logic gates that would usually have just two inputs and one output. \n\nTraces are active when [t]any component[/t] that writes to them is active too, essentially behaving as OR gates.\n\nIn the next page we will see how each gate component in the game behaves based on its inputs. Then we'll take a look at the general components and their special behaviors.",
    "Gate Components",
    "Below we can see how each gate behaves based on its inputs.\nA = Active Inputs, T = Total Inputs\n\n[t]BUFFER -[/t] [i]A > 0[/i]\n[t]AND -[/t] [i]A > 0 && A == T[/i]\n[t]OR -[/t] [i]A > 0[/i]\n[t]XOR -[/t] [i]A % 2 (Odd amount of active inputs)[/i]\n\n[t]NOT -[/t] [i]!BUFFER[/i]\n[t]NAND -[/t] [i]!AND[/i]\n[t]NOR -[/t] [i]!OR[/i]\n[t]XNOR -[/t] [i]!XOR[/i]\n\nYou may have noticed that the Buffer and Or gates (and their inverted counterparts) have the exact same behavior, so you may wonder why both of them are featured in the game. The answer is [t]readability[/t]. We can make our circuits a little easier to understand if we only use the Buffer to delay signals and prevent backflow, leaving the Or gate to its intended use case.\n\nHowever if we leave the readability aside we can also take advantage of the redundancy of components to further [t]compact[/t] our circuits since we would be able to have two \\\"Or gates\\\" or two \\\"Buffers\\\" side by side.",
    "General Components I",
    "On top of the basic logic gates [t]VCB[/t] features several [t]General Components[/t] that enables us to implement special behaviors in our circuits. We'll now take a look at each of those components.\n\nSome of the components have properties that can be changed by [i]right-clicking[/i] their ink on the [i]Circuit Editor panel[/i]. Those properties are [i]globally applied to all instances[/i] of the component on the board.\n\n[t]Latch ON/OFF -[/t] [i]Toggles on the rising edge of any input.[/i]\nDuring simulation we can [t]interact with latches using the mouse[/t]. There are two modes of interaction: Toggle, which makes the latch switch states; and Press, which will keep the latch active while the left mouse button is pressed, or until the latch is toggled by one of its inputs. The Latch has an ON and OFF variants, they behave exactly the same except that the ON version is in the active state when the simulation starts.\n\n[t]Clock -[/t] [i]Toggles every N interval of ticks.[/i]\nThe clock interval can be adjusted on its right-click menu.\n\n[t]LED -[/t] [i]Active when Active Inputs > 0.[/i]\nDuring simulation its color will match its amount of active inputs up to 15, the palette can be customized on the LED's right-click menu and is applied to all LEDs on the board.",
    "General Components II",
    "[t]Timer -[/t] [i]Toggles every N interval of real life milliseconds.[/i]\nThe timer interval can be adjusted on its right-click menu.\n\n[t]Random -[/t] [i]Toggles randomly on the rising edge of any input.[/i]\nBy default the component uses unique time based seeds, but this can be disabled in favor of a user defined seed on its right-click menu.\n\n[t]Breakpoint -[/t] [i]Active when Active Inputs > 0.[/i]\nTriggers a breakpoint on the rising edge of its own state (not of its inputs), which pauses the simulation and reports an event in the Event Log.\n\n[t]Wireless (0 to 3) -[/t] [i]Active when Active Inputs > 0.[/i]\nEach of the four wireless inks behave like a globally connected Or gate.",
    "So far we've learned the fundamentals for creating circuits in [t]VCB[/t] using the several [t]Trace and Component Inks[/t], and this is already enough to build some very simple circuits. However, soon enough we'll find ourselves limited by the physical constraints of the two-dimensional space of the board, with the biggest challenge being how to use traces to connect different components when there are other traces blocking the way.\n\nThis is where the [t]Space Optimization Inks[/t] come in, they give us the freedom that we need to create compact circuits in [t]VCB[/t]. In the next pages we'll take a look at each ink on this group, starting with the most fundamental of them, the Cross. But first you should know that:\n\n[t]1.[/t] Although it's more common to use the Space Optimization inks with traces they [i]work the same with components[/i].\n\n[t]2.[/t] Except for the Bus the Space Optimization inks [i]do not interact with one another when placed side by side[/i], requiring either a trace, component, or bus between them.",
    "Cross Ink",
    "[t]Cross inks[/t] can be placed at the center of perpendicular [t]junction of traces or components[/t] to allow them to coexist independently while crossing one another. Cross inks can be only one pixel wide and must be placed at least one pixel apart, i.e. they don't chain/stack.\n\nIn the two examples on the top of the [i]Circuit 1[/i] we can see the valid usage of cross inks to prevent vertical and horizontal entities from merging while crossing one another. The bottom two examples show invalid usages of cross inks.\n\nDo not forget that crosses [t]can be used with components[/t] too (like logic gates), as shown in [i]Circuit 2[/i].",
    "Circuit 1 - Valid Cross placements at the top, and invalid at the bottom.",
    "Circuit 2 - A single AND gate connected to three traces.",
    "Tunnel Ink",
    "The [t]Tunnel[/t] behaves similarly to the Cross ink but based on the concept of a [t]pair of entrance and exit points[/t] that can be placed further apart.\n\nFor example, a gate, trace, or bus that touches a tunnel ink [i](entrance)[/i] from the left side will connect to the first tunnel [i](exit)[/i] to the right of the entrance that has the same type of ink touching its right side, where there can be anything in the space between the entrance and exit, even [t]other tunnels for different inks[/t] as shown in [i]Circuit 1[/i].",
    "Circuit 1 - Traces of different colors passing through tunnels.",
    "Mesh Ink",
    "The [t]Mesh[/t] is a more versatile alternative to the Wireless inks. It works similarly to the tunnel by allowing traces, buses, and components touching meshes in [t]different locations of the board[/t] to merge together.",
    "Circuit 1 - Traces remotely connected thanks to meshes.",
    "Bus Ink",
    "The [t]Bus[/t] ink allows multiple gates and traces to [t]pass through the same space[/t] on the board.\n\nThere are 6 color variants for the Bus, and like traces of different colors they also [t]merge together when in touch[/t].",
    "Circuit 1 - Multiple entities can pass through the same cells using buses.",
    "Annotation Inks",
    "Lastly, [t]VCB[/t] also features inks which don't interact with circuits but can be used for aesthetic or documentation purposes:\n\n[t]Annotation[/t] - Meant to be used to drawn annotations on the board.\n[t]Filler[/t] - Meant to be used to fill in the empty space between inks in a circuit, so it can also be painted in the decoration layers.\n\nBoth the decoration and filler inks behave the same and can be used interchangeably, the descriptions above are just the suggested usage. The reason for the existence of those two similar inks is that it makes it possible to remove just one from a circuit while keeping the other by using the Filter option of the drawing tools.\n\nFor convenience the [t]None[/t] ink (i.e. empty space) was also made available in this category, being most useful when used in the Filter to restrict drawing only to empty areas.",
    "Editing",
    "Building circuits in [t]VCB[/t].",
    "[t]VCB[/t] has several drawing tools to make building circuits an effortless task, they are:\n\n[t]Array[/t] - a very customizable tool to draw multiple pixels simultaneously.\n[t]Pencil[/t] - draw with a large brush.\n[t]Eraser[/t] - erase pixels from the board.\n[t]Color-picker[/t] - pick an ink to make it the active one.\n[t]Selection[/t] - move, copy, paste, duplicate and more.\n[t]Bucket[/t] - fill areas with the same color.\n\nThere’s also a few special features available for some tools, like the [t]Filter[t].",
    "Array Tool",
    "The [t]Array tool[/t] is the most versatile in the game. It is meant to make the process of [t]drawing multiple traces[/t] or evenly spaced components much easier.\n\nIn the tool options we can change the amount of pixels to draw simultaneously, as well as their spacing and angle. We can also enable the very convenient [t]Auto-cross[/t] option, which automatically takes care of putting a [t]cross ink[/t] whenever we draw over a non-empty space.\n\nHold [t]shift[/t] to activate the [t]axis constraint[/t] while drawing to make straight lines easier.",
    "The [t]Filter[/t] is a feature available for the Array, Pencil and Eraser tools, it allows us to specify which inks we want to paint over. \n\nThis makes it very easy to change the color of a trace without affecting the surrounding ones. It also allows us to draw exclusively in empty areas without accidentally painting over something.",
    "Blueprints",
    "[t]Blueprints[/t] are an easy way of sharing small segments of our circuits with others without having to send the entire project file. They work by copying the selected part of the circuit to the [t]clipboard as text[/t], which we can share with others however we wish. The reverse process is just as easy, we just need to copy the text to the clipboard then click the button that pastes the blueprint back to the circuit board.\n\nThe [t]Blueprint[/t] feature is available through the [t]Selection tool[/t].\n\n[i]Note: the blueprint specification is available at the end of the User Guide in the Appendix chapter.[/i]",
    "When the game is in simulation mode the component and trace inks will have different colors than they do in the editor to indicate their activation state. An ink will have a bright color when the entity it represents (i.e. a component or trace) is [t]ON[/t], and it will have a dark color when it is [t]OFF[/t]. \n\nHowever we can customize these colors by switching to the [t]decoration layers[/t] while editing, they allow us to override the default colors of inks during simulation for each activation state. This enables us to heavily customize the aesthetics of our circuits.\n\nInks that are neither components nor traces (like annotation, filler, and cross) are affected only by the [t]Decoration Low[/t] layer, because those inks are never in an [i]activated[/i] state.\n\nUsing the [t]selection tool[/t] we can also [t]drag and drop[/t] an external image to apply on top of our circuit in the [t]decorations layers[/t].",
    "Edit mode tips",
    "[t]1.[/t] Get used to the Array tool (and its features), it is the most versatile in [t]VCB[/t]’s toolset, followed by the Selection tool.\n\n[t]2.[/t] Take a look at the [t]Sample Projects[/t] included with the game to get inspired.\n\n[t]3.[/t] The game [t]autosaves[/t] every three minutes and before entering simulation mode. Autosaves can be loaded in the [i]Recently Saved Projects[/i] menu.\n\n[t]4.[/t] The pencil tool allows you to draw thick lines, but you should use it very sparingly since it wastes building space.\n\n[t]5.[/t] Use the available [t]shortcuts[/t].\n\n[t]6.[/t] Ink symbols can be shown for traces too by right-clicking the Ink Symbols button.",
    "Simulation mode tips",
    "[t]1.[/t] Use the simulation controls to change the [t]simulation speed, pause[/t] it, and to advance it [t]step-by-step[/t].\n\n[t]2.[/t] Don’t forget that during simulation we can [t]interact with latch[/t] components using the mouse.\n\n[t]3.[/t] Keep an eye on the Event Log card of the Circuit Editor panel, it displays relevant compilation and simulation warnings.\n\n[t]4.[/t] During simulation we can highlight the entire length of a trace or component by hovering it with the mouse while the Highlight Hovered Entity feature is enabled. The feature can be toggled with the \\\"sparks\\\" button at the top right corner of the interface.\n\n",
    "Virtual Devices",
    "In [t]VCB[/t] we can build a lot of things using only inks, but some projects may have specific requirements that make them very difficult or impossible to replicate with traces and components, be it due to size constraints, complexity, performance, or the need for some special behavior.\n\nFor those cases we have the [t]Virtual Devices[/t], they are specialized tools at out disposal to build even more advanced circuits. We'll take a look at each of them in the next pages.",
    "Virtual Memory I",
    "The Virtual Memory, or [t]VMem[/t] for short, has [t]2²⁰ addressable words of 4 bytes[/t]. This is a little over [t]one million rows of 32 bits[/t] to store up to 4 MiB of data, which should be enough to hold the most ambitious programs in [t]VCB[/t]. Note that we don’t have to use all the 32 bits available per word, e.g. when we are working with an 8-bit computer.\n\nCircuits can read and write to the [t]VMem[/t] using two sets of components that behave just like latches but have specific purposes: one set is used to write the [t]memory address[/t], and the other is used to read and write the [t]memory content[/t]. Those special components are placed by the game when the simulation is about to start, but we can configure their position while editing the circuit in the [t]VMem Settings[/t] menu. Circuits can access the Virtual Memory during simulation one address at a time, to [t]read or write[/t] data.\n\nIn the VMem Settings menu, we can also configure a memory region to be [i]preserved at the end of the simulation[/i]. Note that this simply results in a copy operation, so altering the persistent region [i]won't erase any existing data stored in the project's memory[/i].",
    "Virtual Memory II",
    "With the [t]VMem Editor[/t] panel we can conveniently [t]modify the values of the Virtual Memory's words[/t] when editing our projects.\n\nWords can be displayed in either [i]hexadecimal or binary[/i] format, which also affects how input is processed. If the display mode is set to [i]hexadecimal[/i] there's no need to add the [i]\\\"0x\\\"[/i] prefix when entering values. Similarly, if words are being shown in [i]binary[/i] we can directly input binary numbers without having to include [i]\\\"0b\\\"[/i]. In both cases we can also enter [i]decimal[/i] numbers by using the [i]\\\"0d\\\"[/i] prefix.\n\nNote that for advanced use cases it is also possible to edit the Virtual Memory [i]externally[/i].\n\nThe [i]VMem Editor[/i] not only allows us to adjust values in Edit mode but also serves as a [t]debugging tool during simulation[/t]. With it, we can follow the current address of the Virtual Memory, visualize the VMem's state (Red while [i]Locked[/i] and green when [i]Ready[/i]), and observe the changes to the words in real time.\n\n[t]External Editing Notes[/t]\n\n[t]-[/t] The external file must be manually created by the player.\n[t]-[/t] Since [t]VCB[/t] only reads the external file it must be manually copied/moved when the current project is saved/moved to another path.\n[t]-[/t] The external VMem file is read in big-endian order.",
    "Virtual Memory III",
    "[t]When interfacing with the VMem, you should be aware of:[/t]\n\n[t]Locking (2-tick access)[/t] - The VMem becomes [i]locked[/i] in the tick following an address change. While in this state, any input to its latches will be rejected and reported in the Event Log.\n\n[t]Content Precedence[/t] - If both address and content latches are toggled in the same tick, the content change will take precedence. That is to say, the current word will be modified first, and then the new word will be loaded.\n\n[cy][b]WARNING: VMem and Ripple-carry Counters[/b]\n\nPlain RCA counters [b]should not be used[/b] to increment the VMem's address latches. Their [i]\\\"rippling\\\"[/i] property causes latches to toggle at nearly every tick, which not only results in the [i]address jumping around[/i], but also in the [i]wrong address[/i] being set altogether, due to the VMem's locking behavior.[/cy]",
    "Virtual Display",
    "The [t]Virtual Display[/t] allows us to build screens with a higher pixel density and color depth than would be possible using LED components and all the circuitry required to drive them.\n\nIt features [t]eight indexed color modes[/t] to render images based on a [t]customizable palette[/t], and a [t]RGB mode[/t] to render 16M+ colors. The several modes makes it possible to choose the [i]best balance between color depth and memory footprint[/i].\n\nThe [t]VDisplay[/t] can have any resolution as long as it fits inside the board and has a total of 2¹⁸ pixels or less. Additionally, its buffer pointer can be modified during simulation.\n\n",
    "Virtual Input",
    "With the [t]Virtual Input[/t] we can extend our range of interaction with circuits during simulation beyond toggling latches with the mouse.\n\nThis virtual device makes it possible to bind the input from our real life [t]keyboard[/t] directly into an array of components in the board.",
    "Assembly",
    "Programming in [t]VCB[/t].",
    "Overview",
    "To simplify the process of creating programmable computers, [t]VCB[/t] implements a simple yet customizable [t]assembler[/t] that allows us to define our own instruction set.\n\nThe programs we write in the Assembly Editor are assembled into machine code and stored in the Virtual Memory.",
    "Assembly Language",
    "Before we start writing programs we must understand how the assembler translates the text we write into [t]machine code[/t]. To do so, the first concept we must get familiar with are [t]primitives[/t].\n\n[t]Primitives[/t] serve as the building blocks to write programs. They are the atomic pieces of information used by the assembler to populate the Virtual Memory.",
    "Primitives",
    "A primitive is a [t]number[/t] that can be either [t]literal[/t] (e.g. -5, 0b0001, 0xFF) or [t]non-literal[/t] (e.g. foo, bar, baz). Non-literal primitives are [t]aliases[/t] to their literal counterparts and need to be [t]defined[/t] in order to be used. Some of them can be undefined when not needed anymore, or redefined to alias another numeric literal. There are three types of non-literal primitives: Symbols, Pointers, and Labels.\n\nBefore we take a closer look at each type of primitive, let's first explore the structure of the assembly's syntax and understand where the primitives fit into it.",
    "Statements I",
    "The assembler parses code in [t]statements[/t] separated by [i]newlines[/i] or [i]semicolons[/i]. Statements can be either [t]directives[/t] or [t]instructions[/t].\n\n[t]Directives[/t] are actions or settings for the assembler itself. Among other things, they tell the assembler to define, redefine, and undefine non-literal primitives. Since directives are only commands and not data, [t]they are not translated into machine code[/t].\n\n[t]Instructions[/t] are [t]made of[/t] literal and non-literal primitives. Unlike directives, they are the actual [t]data[/t] composing our programs, and [t]will be converted into machine code[/t].\n\nWhen the machine code is being generated, all the primitives (numbers) in an instruction are bitwise [t]OR[/t]ed* together and stored in the VMem.\n\n*Unless an [i]expression[/i] is detected.",
    "Expressions",
    "We can [t]override the automatic ORing[/t] in instructions by using operators to form expressions. They allow us to perform bitwise and arithmetic operations with the primitives to determine how they will be evaluated before being stored in the VMem.\n\nExpressions are [i]restricted to instructions[/i] and cannot be used within directives. Note that with the exception of parentheses, operators [i]must have spaces separating them[/i]. All the supported operators are listed below.\n\n[b][cy]+[/cy][/b] Addition\n[b][cy]-[/cy][/b] Subtraction\n[b][cy]*[/cy][/b] Multiplication\n[b][cy]/[/cy][/b] Division\n[b][cy]%[/cy][/b] Modulo\n[b][cy]~[/cy][/b] Bitwise NOT\n[b][cy]&[/cy][/b] Bitwise AND\n[b][cy]|[/cy][/b] Bitwise OR\n[b][cy]^[/cy][/b] Bitwise XOR\n[b][cy]<<[/cy][/b] Bit shifting left\n[b][cy]>>[/cy][/b] Bit shifting right\n[b][cy]([/cy][/b] Begin subexpression\n[b][cy])[/cy][/b] End subexpression",
    "Statements II",
    "[code][ca]>[/ca] [cy]symbol[/cy] [cv]foo[/cv] [cg]0b0001[/cg]\n[ca]>[/ca] [cv]foo[/cv] [cg]0b1000[/cg][cy];[/cy] [cg]0xF7[/cg][/code]\n\nIn the above example we have 3 statements, the first is a [t]directive[/t] and the two others are [t]instructions[/t]. The directive is just defining a primitive named [t]foo[/t], and it won’t be assembled into machine code as it does not contain any data.\n\nBut the following statement, [t]foo 0b1000[/t], does have primitives, two of them: it has the non-literal [t]foo[/t] (0b0001) defined earlier, and a numeric literal (0b1000). These two primitives will be [t]OR[/t]ed together to become a single instruction (0b1001) which will be stored in the Virtual Memory, followed by the third statement in the next address.",
    "Assembler",
    "When the game begins to translate instructions into machine code it [t]skips the first word[/t] of the Virtual Memory [i](address 0 is reserved and should not be used)[/i] and starts at address 1. The assembled data is stored in [t]big-endian order[/t] with negative values represented in [t]Two's Complement[/t].\n\nThe assembler ignores blank lines and comments in the code, which are indicated with a [t]#[/t] symbol.\n\n[code][ca]>[/ca] [ce]# This is a comment.[/ce]\n[ca]>[/ca] [cv]psh[/cv][cy];[/cy] [cv]cal[/cv] [cb]Print[/cb][cy];[/cy] [cv]ret[/cv] [ce]# Another comment.[/ce][/code]\n\nNow that we’ve learned about the assembly’s syntax and how instructions become machine code we can take a closer look into each type of [t]primitive[/t].",
    "Primitives - Numerics",
    "[t]Numerics[/t] are the literal primitives. They can be expressed in base 10, hexadecimal, or binary (floating points are not supported), and must be no larger than 32 bits in order to fit into the words of the Virtual Memory.\n\n[code][ca]>[/ca] [cg]10515545[/cg][cy];[/cy] [cg]-1[/cg][cy];[/cy] [cg]0xFFFF[/cg][cy];[/cy] [cg]0b01101010[/cg][/code]\n\nUnderscores can be used in numerics to improve their readability.\n\n[code][ca]>[/ca] [cg]1_000_000[/cg][cy];[/cy] [cg]0b0000_1000[/cg][/code]",
    "Primitives - Symbols",
    "[t]Symbols[/t] are the primitives for user-defined values, they are useful to create [t]mnemonics[/t] for opcodes. They must be defined with an [t]identifier[/t] followed by a [t]numeric literal[/t]. Optionally, symbols can also be redefined or undefined.\n\n[code][ca]>[/ca] [cy]symbol[/cy] [cv]add[/cv] [cg]0xFF[/cg] [ce]# “add” from now on means “0xFF”.[/ce]\n[ca]>[/ca] [cy]resymb[/cy] [cv]add[/cv] [cg]125[/cg]  [ce]# “add” from now on means “125”.[/ce]\n[ca]>[/ca] [cy]unsymb[/cy] [cv]add[/cv]      [ce]# “add” is undefined.[/ce][/code]\n\nSymbols are highlighted in purple if they remain defined until the end of the program, otherwise they default to red.",
    "Primitives - Pointers",
    "[t]Pointers[/t] are the primitives for memory addresses. Due to the pointer’s nature a statement that defines it is [t]both a directive and an instruction[/t]. A pointer can be defined with a [t]numeric literal[/t] address, or have one automatically assigned to it using the [i]inline[/i] keyword. Use [t]repoint[/t] and [t]unpoint[/t] to delimit its scope.\n\nIn the example below, we store the number [i]30[/i] at the address [i]0xFF[/i], which is now aliased to [i]\\\"foo\\\"[/i].\n\n[code][ca]>[/ca] [cy]pointer[/cy] [cr]foo[/cr] [cg]0xFF 30[/cg][/code]\n\nIn this second case, we store the number [i]5[/i] between the previous and next instructions using the [i]inline[/i] keyword. The actual address will be automatically determined by the assembler.\n\n[code][ca]>[/ca] [cy]pointer[/cy] [cr]bar[/cr] [cm]inline[/cm] [cg]5[/cg][/code]",
    "Primitives - Labels",
    "[t]Labels[/t] are also primitives for memory addresses, with a few key differences: 1. They point to the [t]first instruction[/t] that comes after their definition; 2. They [t]cannot be undefined[/t]; and 3. They have [t]global scope[/t] and can be used in statements that come [t]before[/t] their definition. Labels can be defined with the [t]@[/t] symbol.\n\n[code][ca]>[/ca] [cy]@[/cy] [cb]Sum[/cb]\n[ca]>[/ca] [cv]lia[/cv] [cg]10[/cg][cy];[/cy] [cv]ldb[/cv] [cr]value[/cr][cy];[/cy] [cv]add[/cv]\n\n[ca]>[/ca] [cy]@[/cy] [cb]MyOtherFunction[/cb]\n[ca]>[/ca] [cv]psh[/cv][cy];[/cy] [cv]cal[/cv] [cb]Sum[/cb][cy];[/cy] [cv]ret[/cv] [ce]# “Sum” is an alias to lia 10’s VMem address.[/ce]",
    "Review",
    "Before diving into more advanced features, let's take a moment to review what we have learned so far.\n\nWe write assembly code using [t]statements[/t] separated by [i]newlines[/i] or [i]semicolons[/i]. [t]Directive[/t] statements define the [t]primitives[/t] (numbers) that we use in [t]instruction[/t] statements, which are the actual [t]data[/t] of our programs.\n\nWhen generating the machine code, the assembler takes all the primitives in an instruction and [t]OR[/t]s them together, unless we form an expression using [t]operators[/t].\n\nThe [t]pointer[/t] primitive is special because its definition or redefinition is [t]both a directive and an instruction[/t]. The statement defining a pointer is stored in the specified address of the Virtual Memory, unless the [i]inline[/i] keyword is used.",
    "Origin Directive",
    "Using the [t]origin[/t] directive we can specify the memory address where the assembler should store the machine code generated for the subsequent instructions. This directive is particularly useful when we want to [i]store data separately[/i] from the program itself.\n\n[code][ca]>[/ca] [ck]origin[/ck] [cg]0xFF00[/cg]\n[ca]>[/ca] [cg]0b1010[/cg] [ce]# Stored at address 0xFF00.[/ce]\n[ca]>[/ca] [cg]0b0101[/cg] [ce]# Stored at address 0xFF01.[/ce][/code]\n\nWe can also use the keyword [t]orgprev[/t] to revert the most recent origin directive, or [t]orgbase[/t] to revert them all. For the example below, consider that after translating some instructions to machine code, the assembler is at the address [i]0xA1[/i].\n\n[code][ca]>[/ca] [ck]origin[/ck] [cg]0xB1[/cg]\n[ca]>[/ca] [ck]origin[/ck] [cg]0xC1[/cg]\n[ca]>[/ca] [ck]origin[/ck] [cg]0xD1[/cg]\n[ca]>[/ca] [ck]origin[/ck] [cg]0xE1[/cg]\n[ca]>[/ca] [ck]origin[/ck] [cm]orgprev[/cm] [ce]# Address set to 0xD1.[/ce]\n[ca]>[/ca] [ck]origin[/ck] [cm]orgprev[/cm] [ce]# Address set to 0xC1.[/ce]\n[ca]>[/ca] [ck]origin[/ck] [cm]orgbase[/cm] [ce]# Address set to 0xA1.[/ce][/code]",
    "Macros I",
    "[t]Macros[/t] allow us to improve the readability of our programs by abstracting the expressions required for complex instructions.\n\nLet's consider a hypothetical [t]mov[/t] instruction as an example. In this instruction, bits [7:4] determine the opcode, bits [3:2] represent the source register, and bits [1:0] indicate the destination register. Due to this instruction format, we can't rely on the assembler's automatic [i]OR[/i]ing, as we need to offset the position of the registers. To achieve this, we can use an expression that bitshifts the source register to the correct position and [i]OR[/i]s all the arguments together, as shown in the example below.\n\n[code][ca]>[/ca] [cv]mov[/cv] [cy]|[/cy] [cv]rgA[/cv] [cy]<<[/cy] [cg]2[/cg] [cy]|[/cy] [cv]rgB[/cv]\n[ca]>[/ca] [cv]mov[/cv] [cy]|[/cy] [cv]rgB[/cv] [cy]<<[/cy] [cg]2[/cg] [cy]|[/cy] [cv]rgA[/cv][/code]\n\nHowever, it would be very inconvenient to write long expressions like these for every instruction in our program. Let's see how we can avoid this scenario with the help of a [i]macro[/i].\n\n[code][ca]>[/ca] [cn]macro[/cn] [co]mov[/co] [cy]{[/cy][cg]0b11000000[/cg] [cy]|[/cy] [cr]a[/cr][cy]? <<[/cy] [cg]2[/cg] [cy]|[/cy] [cr]b[/cr][cy]?}[/cy]\n[ca]>[/ca] [co]mov[/co] [cv]rgA[/cv] [cv]rgB[/cv]\n[ca]>[/ca] [co]mov[/co] [cv]rgB[/cv] [cv]rgA[/cv][/code]\n\nAs demonstrated above, thanks to [i]macros[/i], our instructions can be made simpler and more concise, allowing us to create longer and more complex programs without compromising readability.",
    "Macros II",
    "To define a macro we begin with the [t]macro[/t] keyword, followed by an [t]identifier[/t], and finally, the [t]body[/t] enclosed in curly braces. The macro's arguments are indicated with a [t]lowercase letter followed by a question mark[/t]. When the macro is expanded, every occurrence of the [i]\\\"a?\\\"[/i] placeholder will be replaced with the first argument, followed by the [i]\\\"b?\\\"[/i] placeholder for the second argument, and so on. Note that macros [t]cannot be chained/nested[/t], neither in their definition nor in their usage.\n\nLike symbols and pointers, macros can also be redefined and undefined, using the keywords [t]remac[/t] and [t]unmac[/t], respectively.\n\nError messages concerning macros can be distinguished by their color. Errors flagged by the assembler are presented in [i]red[/i], while the preprocessor highlights them in [i]orange[/i].",
    "Bookmarks",
    "Bookmarks provide a [t]quick way to navigate[/t] through our code by adding labels beside the assembly editor, which we can click to go to the lines where they were defined. Bookmarks are ignored by the assembler, use [t]bookmark[/t] and [t]sub_bookmark[/t] to declare them.\n\n[code][ca]>[/ca] [ca]bookmark[/ca] [cr]FunctionForSum[/cr] [ce]# Topic bookmark.[/ce]\n[ca]>[/ca] [cv]lia[/cv] [cg]10[/cg][cy];[/cy] [cv]ldb[/cv] [cr]value[/cr][cy];[/cy] [cv]add[/cv]\n\n[ca]>[/ca] [ca]sub_bookmark[/ca] [cr]PrintSumResult[/cr] [ce]# Subtopic bookmark.[/ce]\n[ca]>[/ca] [cv]psh[/cv][cy];[/cy] [cv]cal[/cv] [cb]MyFunction[/cb][cy];[/cy] [cv]ret[/cv]",
    "External Editing",
    "If you would like to use an [t]external text editor[/t] to write the assembly code you may do so by enabling the respective option in the [i]External Editing[/i] button, located below the [i]Bookmarks[/i] icon in the [i]Assembly Editor[/i] panel. The game will then read the contents of a text file with the same name and path as the current project, ending with the [i]\\\".vcbasm\\\"[/i] extension.\n\n[t]External Editing Notes[/t]\n\n[t]-[/t] The external file must be manually created by the player.\n[t]-[/t] Since [t]VCB[/t] only reads the external file it must be manually copied/moved when the current project is saved/moved to another path.",
    "Conclusion",
    "Wrapping up.",
    "Sample Projects",
    "[t]VCB[/t] comes with [t]sample projects[/t] to showcase some of the circuits that can be build in the game. The [i]32-bit Computer[/i] project for example features an ALU, an instruction decoder that accesses the VMem, and a scrolling display.\n\nThe sample projects are available through the [t]open book icon[/t] in the top-right corner of the UI.",
    "Figure 1 - 32-bit Computer included in the sample projects.",
    "Developer's Note",
    "You should now have all the essential knowledge required to start playing with [t]Virtual Circuit Board[/t], but don’t forget to take a look at the included Sample Projects to see all the theory you’ve learned so far applied in practice.\n\nIf you need any help with [t]VCB[/t] feel free to reach me out in the game’s communities.\n\nI hope you have as much fun playing the game as I had developing it.\n\n\n[t]– Mause[/t]",
    "Appendix",
    "Supplementary information.",
    "Blueprint Specification",
    "The details of the blueprint format can be found below.\n\n[t]Overview[/t]\n- Blueprints begin with the [i]\\\"VCB+\\\"[/i] prefix.\n- Data is encoded in Base64.\n- Bytes are in big-endian order.\n\n[t]Header[/t]\n3-byte blueprint version\n6-byte checksum (truncated SHA-1) of the remaining characters of the blueprint string\n4-byte width\n4-byte height\n\n[t]Layer Block(s)[/t]\n4-byte block size\n4-byte layer id (Logic = 0, Deco On = 1, Deco Off = 2)\n4-byte uncompressed buffer size\nN-byte zstd-compressed RGBA8 buffer\n\n[t]Text Block(s)[/t]\n4-byte block size\n4-byte data id (Name = 1024, Description = 1025, Tags = 1026)\n4-byte uncompressed buffer size\nN-byte zstd-compressed UTF-8 buffer\n\n[t]Notes[/t]\n- The Logic layer block must be present in all blueprints.\n- Decoration layer blocks are optional but if used both of them must be included.\n- All the text blocks are optional.\n\n[t]Legacy Blueprints[/t]\n- Blueprints created in early versions of VCB were encoded with a legacy format. They can be identified by the prefix [i]\\\"KLUv/\\\"[/i].",
    "[i]Virtual Circuit Board[/i]\nCopyright (c) 2022-2024 Reverie Foundry. All rights reserved.\n\n[i]Made with Godot Engine.[/i]\nThird-party licenses are available at the installation directory.",
    "Enable Virtual Display",
    "Visible in Edit mode",
    "Focus view",
    "Move camera to\nthe display's center",
    "Center",
    "Move camera to the\ndisplay's top left corner",
    "L",
    "Move camera to the\ndisplay's bottom right corner",
    "R",
    "Position XY",
    "Res. XY",
    "Scale XY",
    "The location of the pointer to the video buffer.\n\nIf THIS field is set to 1024, for example, the Virtual Display will go to\naddress 1024 in the VMem and use the value stored THERE as the\npointer to the actual location of the image to render.\n\nThis behavior makes it possible to swap the rendered image at once by\nchanging the buffer location (in this case stored at address 1024) to\nanother position in memory containing the data to a different image.",
    "Address",
    "Maximum amount of bits to use for pixel data per VMem word.\n\nThe VDisplay will use the largest multiple of the Color Depth\nsmaller than the Word Size as the amount of pixels per word.\n\nFor example, if the Color Depth is set to 3-bit and the Word Size\nis set to 16, the VDisplay will operate with the lowest 15 bits of\nwords (i.e. 5 pixels) and ignore the highest 17 remaining bits.",
    "Word Size",
    "Color Depth",
    "Direction at which pixels are drawn. Both modes render from\nthe top-left corner of the Virtual Display to its bottom-right.\n\nHorizontal - draws in rows from left to right, top to bottom.\nVertical - draws in columns from top to bottom, left to right.",
    "Direction",
    "1-bit, 2 colors from palette,\n32 pixels per VMem address\nordered in big-endian.",
    "Palette",
    "Yellow - most significant bits\nBlue - least significant bits",
    "Enable Virtual Input",
    "Move camera to\nthe interface bits",
    "Move camera to the\nMost Significant Bit",
    "MSB",
    "Move camera to the\nLeast Significant Bit",
    "LSB",
    "Bits",
    "Offset XY",
    "Size XY",
    "Press - active while the input keys are pressed.\nPulse - active for a single tick.",
    "Mode",
    "Key Name",
    "Click to Check",
    "Bindings are separated with newlines\nand defined with the syntax:\n\n<key_name> = <value>\n\nThe binding's value can be written as a\nnumber (binary, base 10, hexadecimal),\nor alternatively as a list of bits:\n\n\\\"[3, 1]\\\" is equivalent to \\\"0b1010\\\".",
    "Bindings",
    "Q = 0x20\nW = 16\nE = [3]\nR = 0x4\nT = 0b10\nY = 0b1",
    "External VMem",
    "The external VMem file\nmust have the same path\nas the project, ending with\nthe \\\".vcbmem\\\" extension.",
    "Copy the vcbmem's data\nto the project's file and\ndisable external editing.",
    "Hex",
    "0x00001",
    "Edit VMem externally",
    "Enable VMem",
    "Legend",
    "Yellow - Most Significant Bits\nBlue - Least Significant Bits",
    "Address Latches",
    "Move camera to\nthe address bits",
    "Content Latches",
    "Move camera to\nthe content bits",
    "At the end of the simulation, the persistent section of the VMem will be\npreserved, either replacing the values manually set through the VMem\nEditor, or writing to the external VMem file (.vcbmem), if enabled.",
    "Persistent Memory",
    "First address (inclusive) of\nthe persistent memory range",
    "From",
    "Last address (inclusive) of\nthe persistent memory range",
    "To",
    "New project\n$fs_new_project",
    "Open project\n$fs_open_project",
    "Save project\n$fs_save_project",
    "Save project as",
    "Open recent projects and autosaves",
    "Recent Projects",
    "Recent projects and autosaves\nwill be shown here.",
    "Project Name",
    "Autosaves",
    "Undo last action",
    "Redo last action",
    "Autosaving",
    "new_circuit.vcb",
    "Project Title",
    "Virtual Circuit Board",
    "Beta build",
    "aaaaaaaaaaaaaaaaaaaaaa",
    "User guide",
    "Open sample projects",
    "Changelog",
    "Quit",
    "Save circuit as",
    "Toggle left sidebar\n$ui_toggle_left_sidebar",
    "Open project",
    "Save project",
    "Compile only the visible portion of the board. This can be\nuseful to view the statistics of a specific area in the circuit.",
    "Toggle game mode",
    "Simulate",
    "Previous step\n$sm_prev_update",
    "Start simulation paused",
    "Pause simulation\n$sm_pause_simulation",
    "Next step\n$sm_next_update",
    "Ticks to advance in Step Mode",
    "aaa",
    "Target simulation speed\nRight-click to type a value instead",
    "Target simulation speed\nRight-click to use a slider instead",
    "5000000",
    "Render with decoration layers",
    "365056 IPS",
    "Highlight hovered entity",
    "Allow Virtual Input to consume\nkeyboard input from binded keys",
    "Display ink symbols when zoomed-in.\nRight-click to toggle symbols for traces",
    "Ink Symbols Overlay",
    "Show traces symbols",
    "Flat rendering",
    "Toggle assembly editor",
    "Display",
    "Show",
    "Resolution",
    "Target simulation frequency",
    "Position",
    "Scale",
    "Main Color",
    "BG Color",
    "Digits",
    "Toggle right sidebar\n$ui_toggle_right_sidebar",
    "Circuit Editor",
    "Blueprint Library",
    "User Guide",
    "VMem Editor",
    "VMem Settings",
    "Notes",
    "Swap panel",
    "Menu Title",
    "Maximize dock",
    "Menu Titleg"
]