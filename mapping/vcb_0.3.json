[
  "Bookmarks Title",
  "This is a testaaaaaaaaaaaaa",
  "Expand/Collapse All",
  "About",
  "Virtual Circuit Board\nCopyright (c) 2022-2023 Reverie Foundry. All rights reserved.\n\nMade with Godot Engine.\nThird-party licenses are available at the installation directory.",
  "Close",
  "New in Virtual Circuit Board",
  "Virtual Circuit Board\nCopyright (c) 2022 Reverie Foundry. All rights reserved.\n\nMade with Godot Engine.\nThird-party licenses are available at the installation directory.",
  "Close",
  "Are you sure you want to quit?",
  "Yes",
  "No",
  "Photosensitive Seizure Warning",
  "        A very small percentage of people may experience a seizure when exposed to certain visual images, including flashing lights or patterns that may appear in video games. Even people who have no history of seizures or epilepsy may have an undiagnosed condition that can cause these “photosensitive epileptic seizures” while watching video games.\n\n        These seizures may have a variety of symptoms, including lightheadedness, altered vision, eye or face twitching, jerking or shaking of arms or legs, disorientation, confusion, or momentary loss of awareness. Seizures may also cause loss of consciousness or convulsions that can lead to injury from falling down or striking nearby objects.\n\n        Immediately stop playing and consult a doctor if you experience any of these symptoms. Parents should watch for or ask their children about the above symptoms. Children and teenagers are more likely than adults to experience these seizures. The risk of photosensitive epileptic seizures may be reduced by taking the following precautions: Play in a well-lit room; Do not play if you are drowsy or fatigued.\n\n    If you or any of your relatives have a history of seizures or epilepsy, consult a doctor before playing.",
  "Close",
  "Settings",
  "Window",
  "Framerate Limiter",
  "UI Scale",
  "1x",
  "Graphics",
  "Text Editors",
  "Assembly Font Size",
  "Notes Font Size",
  "Close",
  "Shortcuts",
  "Action",
  "Key or Button",
  "Action Name",
  "Close",
  "Section Title",
  "Action Name",
  "Action Name",
  "Assembly Editor",
  "When binding an action press \\\"Esc\\\" to cancel, and \\\"Backspace\\\" to clear.",
  "Reset",
  "Close",
  "Discard unsaved changes?",
  "Save",
  "Discard",
  "Cancel",
  "Warning",
  "Ok",
  "Option",
  "Option",
  "0",
  "Using external\nassembly code.\n\nThe external assembly file\nmust have the same path\nas the project, ending with\nthe \\\".vcbasm\\\" extension.",
  "Force Reload",
  "No errors.",
  "L 1\nC 1",
  "Layers",
  "Layer Logic",
  "Tools",
  "Cursor Info",
  "Hovered Ink  ",
  "None",
  "Position     ",
  "X",
  "2000",
  "Y",
  "1024",
  "Inks",
  "Space Optimization",
  "Traces",
  "Gates",
  "Inverted Gates",
  "General Components",
  "Clock Interval (ticks)",
  "LED Palette",
  "000000, ffffff, ff0000, 00ff00, 0000ff, ff0000, 00ff00, 0000ff, ff0000, 00ff00, 0000ff, ff0000, 00ff00, 0000ff, ff0000, 00ff00",
  "0/16",
  "Timer Interval (msec)",
  "Random Seed",
  "Annotation",
  "Bucket",
  "Brush",
  "Size",
  "8",
  "Shape",
  "Filter",
  "Array",
  "Repeat",
  "1",
  "Angle",
  "Offset",
  "X",
  "1",
  "Y",
  "Space Y",
  "1",
  "Rotate",
  "Auto-cross",
  "Filter",
  "Simulation",
  "Mouse Interaction Mode",
  "Toggle",
  "Press",
  "Statistics",
  "View",
  "Abs",
  "Default",
  "Cells: 123",
  "123",
  "Entities: 123",
  "Selection",
  "Delete",
  "Transform",
  "Rotate",
  "Mirror",
  "Blueprint String",
  "Drag & Drop",
  "Decoration",
  "Event Log",
  "Tick 1026264\nBreakpoint reached at 128, 2040",
  "Tick 1026264\nBreakpoint reached at 128, 2040",
  "Filter",
  "Invert",
  "All",
  "Clear",
  "inpt",
  "All",
  "None",
  "Lorem ipsum.",
  "No errors.",
  "L 1\nC 1",
  "Flow control II",
  "In the example image we can see a simple connection between two components: The Latch at the top outputs its state to the yellow trace, because there’s a Write ink between the latch and the trace.\n\nThe Buffer at the bottom receives signals from the yellow trace as input, because there’s a Read ink between the trace and the Buffer.\n\nIn this example signals will flow from the Latch to the Buffer, but not the opposite.",
  "Description of the Image",
  "Start",
  "End",
  "Prev",
  "Next",
  "In this guide you will learn everything you need to get started with [i]Virtual Circuit Board[/i].",
  "Some pages in the User Guide make usage of images to assist with the text explanation. These images are numbered and may be refered as either [i]figures[/i] or [i]circuits[/i]. The [i]circuit[/i] images feature a button at their top-right corner that allows us to paste the example circuit into the board so we can closely inspect it.\n\nTake a look at the [i]Figure 1[/i] and the [i]Circuit 1[/i].",
  "The basics about [i]Virtual Circuit Board[/i].",
  "[t]VCB[/t] is separated in two modes, edit and simulation.\n\nWhile [t]editing[/t] we can use the drawing tools to modify our circuit, and the assembly editor to write programs. And during [t]simulation[/t] we can see our circuit running and interact with it.\n\nWe can alternate between edit and simulation mode by clicking the [t]Edit/Simulate[/t] button in the simulation controls section of the game’s interface.\n\nEntering simulation mode may take a few seconds while the game [t]compiles[/t] the circuit.",
  "[t]VCB[/t] features a high-performant event-driven [t]simulation engine[/t].\n\nThe simulation is [t]deterministic[/t], which means that a given circuit will be simulated identically every time without any sort of randomness affecting its timings.\n\nBy being [t]event-driven[/t] the engine only processes active parts of circuits, allowing it to run at up to [t]millions[/t] of updates per second, depending on the player’s hardware.\n\nThe tickrate (speed) of the simulation can be easily adjusted. The simulation can also be paused and manually advanced by a given amount of steps.\n",
  "Navigating the game's UI.",
  "[t]Pan[/t]\nHold [i]MMB (Middle Mouse Button)[/i] and drag the mouse to pan the view. Alternatively we can also use the arrow keys to move the camera.\n\n[t]Zoom[/t]\nRotate the [i]mouse wheel[/i] up/down to zoom in/out, or use the [i](=)[/i] and [i](-)[/i] keys. Zooming is aligned with the mouse cursor position.\n\n[i]Note: the camera controls can be rebinded in the Shortcuts menu.[/i]\n\n[t]Shortcuts[/t]\nThe game’s shortcuts are listed in the [i]Shortcuts menu[/i], where they can be remapped. The Shortcuts tab is accessible through the options menu on the top-right corner of the UI [i](gear icon)[/i].",
  "[t]VCB[/t] features a modular and customizable interface thanks to its [t]docking system[/t]. There are four docks in total, laid out in sidebars on both sides of the screen. Each dock can be set to display one of the [i]panels[/i] available in the game, like this [i]User Guide[/i]. Most panels however act like editors that allow us to work with specific aspects of our projects. They are:\n\n[t]Circuit Editor[/t] - contains the options related to editing the circuit board, like drawing, erasing, selecting, and others.\n[t]Assembly Editor[/t] - where we can write programs that will be available in the Virtual Memory during simulation.\n[t]Notes[/t] - a space dedicated for project documentation.\n[t]User Guide[/t] - the game's reference manual.\n[t]VMem Settings[/t] - the menu that allows us to set the position of the VMem on the board.\n[t]Virtual Display[/t] - contains all settings related to the VDisplay.\n\nWe can swap a dock's panel by clicking on the icon on its top-left corner, beside the panel title.\n\nThe docks, as well as the sidebars, can also be resized and collapsed, allowing us to further adjust the interface.",
  "Some UI elements exhibit a [t]secondary behavior when right-clicked[/t], the slider widget that controls the simulation speed for example, will turn into a numerical input field for precise control of the tickrate. \n\nThe UI elements with alternative actions can be spotted by the change of the mouse cursor when it passes over them, it will display a [i]plus sign and an yellow color[/i].",
  "How circuits work in [t]VCB[/t].",
  "In [t]VCB[/t] we build circuits by drawing in a square canvas referred as [t]Board[/t] using specific colors called [t]Inks[/t].\n\nThe majority of inks are either [t]Components[/t] like logic gates, or the [t]Traces[/t] used to carry signals between them, but there is also inks that are not [t]Entities[/t], i.e. which are not logical objects that get simulated. Those kind of inks are divided in two groups: [t]Space Optimization[/t], composed of inks that allow us to compact our circuits, and [t]Annotation[/t], which are simply static inks that do not interact with any others.\n\nIn the next pages we’ll learn all about components and traces; the relation between inks and entities; how the connection between entities works; and the types of components available, including how each one of them behaves. Then we'll take a look at the Space Optimization inks, and how we can take advantage of them to build compact circuits.",
  "[t]Components[/t] and [t]traces[/t] are the foundation of circuits in [t]VCB[/t].\n\n[t]Components[/t] are devices that perform logic operations to change their state and output, usually based on one or more external inputs. The eight standard logic gates are all components, but [t]VCB[/t] also implements some special others.\n\n[t]Traces[/t] (wires) are [t]VCB[/t]’s equivalent of the traces/tracks printed in PCBs. Traces conduct signals and are used to connect components to one another.",
  "Component inks of the same type will turn into a [t]single entity[/t] when drawn side by side (left and right, or up and down). In [i]Circuit 1[/i] there are 4 groups of OR Gate inks, which will become 4 individual components during simulation. \n\nAs we can see entities can have [t]any kind of shape or size[/t] as long as their inks are neighbors.\n\nDifferent component inks (e.g. OR & XOR) won’t be merged when placed side by side.",
  "Different from the components, traces will turn into a single entity [t]even when they are not all the same ink[/t], this is because traces have 16 color variations, in addition to other two special trace inks (Write and Read) that indicate where connections should be made and the direction of signal flow.\n\nIn the circuit below there are four traces. They all have the flow control inks (which are still part of the traces) scattered along them.",
  "In [t]VCB[/t] components and traces do not automatically connect to each other when placed side by side, instead they require an intermediate ink that dictates the direction of signal flow, which allows a fine control over signal transmission.\n\nThe inks used for flow control are called Write and Read. They are named from the point of view of components, which generate signals to be send across traces, in other words, they [color=#e06666][b]write[/b][/color] their [color=#e06666][b]output[/b][/color] into traces. When signals arrive at their destinations the components [color=#6fa8dc][b]read[/b][/color] them to their [color=#6fa8dc][b]inputs[/b][/color]. See the example below.\n\nComponent -> [color=#e06666][b]Write[/b][/color] -> Trace -> [color=#6fa8dc][b]Read[/b][/color] -> Component",
  "It is important to keep in mind that the [iw]Write[/iw] and [ir]Read[/ir] inks are still traces, despite their special behavior of making connections.\n\nWhen [iw]Write[/iw] or [ir]Read[/ir] inks are used in the middle of a trace they do not create a connection between the two sides of the trace since [t]connections are only made between traces and components[/t].\n\nA [iw]Write[/iw] or [ir]Read[/ir] ink in the middle of a trace is merely another part of the trace itself, just like any of the 16 trace variants.",
  "In the [i]Circuit 1[/i] we can see a simple connection between two components: The Latch at the top outputs its state to the yellow trace, because there’s a [color=#e06666][b]Write[/b][/color] ink between the latch and the trace.\n\nThe Buffer at the bottom receives signals from the yellow trace as input, because there’s a [color=#6fa8dc][b]Read[/b][/color] ink between the trace and the Buffer.",
  "The flow control inks must be in direct contact with components, that is, a [color=#e06666][b]Write[/b][/color] or [color=#6fa8dc][b]Read[/b][/color] ink should have a component as one of its four [t]immediatly neighbor cells[/t] in order to form a connection with it.\n\nThis is important to keep in mind when we start to work with the Space Optimization inks.",
  "Components can [t]write[/t] to traces, [t]read[/t] from them, or [t]both[/t], but their connection is [t]only made once[/t]. This means that they are either connected (in any of the three possible ways) or they are not. \n\nIn other words the connection between two entities is [t]not countable[/t], regardless of how many points of contact they have or how large the contact area is.",
  "The LED component changes colors based on its amount of active inputs. In the two examples at the top of the [i]Circuit 1[/i] the LEDs have the same color because both of them are only receiving a signal [t]from one trace[/t].\n\nThe LEDs at the bottom have a different color because both are receiving [t]3 signals instead of one[/t]. In the left version two other traces were added, and in the right the signal from the trace was first passed to a Buffer, and from it 3 individual traces were connected to the LED. ",
  "Both components and traces support [t]multiple input and output connections[/t], including the logic gates that would usually have just two inputs and one output. \n\nTraces are active when [t]any component[/t] that writes to them is active too, essentially behaving as OR gates.\n\nIn the next page we will see how each gate component in the game behaves based on its inputs. Then we'll take a look at the general components and their special behaviors.",
  "Below we can see how each gate behaves based on its inputs.\nA = Active Inputs, T = Total Inputs\n\n[t]BUFFER -[/t] [i]A > 0[/i]\n[t]AND -[/t] [i]A > 0 && A == T[/i]\n[t]OR -[/t] [i]A > 0[/i]\n[t]XOR -[/t] [i]A % 2 (Odd amount of active inputs)[/i]\n\n[t]NOT -[/t] [i]!BUFFER[/i]\n[t]NAND -[/t] [i]!AND[/i]\n[t]NOR -[/t] [i]!OR[/i]\n[t]XNOR -[/t] [i]!XOR[/i]\n\nYou may have noticed that the Buffer and Or gates (and their inverted counterparts) have the exact same behavior, so you may wonder why both of them are featured in the game. The answer is [t]readability[/t]. We can make our circuits a little easier to understand if we only use the Buffer to delay signals and prevent backflow, leaving the Or gate to its intended use case.\n\nHowever if we leave the readability aside we can also take advantage of the redundancy of components to further [t]compact[/t] our circuits since we would be able to have two \\\"Or gates\\\" or two \\\"Buffers\\\" side by side.",
  "On top of the basic logic gates [t]VCB[/t] features several [t]General Components[/t] that enables us to implement special behaviors in our circuits. We'll now take a look at each of those components.\n\nSome of the components have properties that can be changed by [i]right-clicking[/i] their ink on the [i]Circuit Editor panel[/i]. Those properties are [i]globally applied to all instances[/i] of the component on the board.\n\n[t]Latch ON/OFF -[/t] [i]Toggles on the rising edge of any input.[/i]\nDuring simulation we can [t]interact with latches using the mouse[/t]. There are two modes of interaction: Toggle, which makes the latch switch states; and Press, which will keep the latch active while the left mouse button is pressed, or until the latch is toggled by one of its inputs. The Latch has an ON and OFF variants, they behave exactly the same except that the ON version is in the active state when the simulation starts.\n\n[t]Clock -[/t] [i]Toggles every N interval of ticks.[/i]\nThe clock interval can be adjusted on its right-click menu.\n\n[t]LED -[/t] [i]Active when Active Inputs > 0.[/i]\nDuring simulation its color will match its amount of active inputs up to 15, the palette can be customized on the LED's right-click menu and is applied to all LEDs on the board.",
  "[t]Timer -[/t] [i]Toggles every N interval of real life milliseconds.[/i]\nThe timer interval can be adjusted on its right-click menu.\n\n[t]Random -[/t] [i]Toggles randomly on the rising edge of any input.[/i]\nBy default the component uses unique time based seeds, but this can be disabled in favor of a user defined seed on its right-click menu.\n\n[t]Breakpoint -[/t] [i]Active when Active Inputs > 0.[/i]\nTriggers a breakpoint on the rising edge of its own state (not of its inputs), which pauses the simulation and reports an event in the Event Log.\n\n[t]Wireless (0 to 3) -[/t] [i]Active when Active Inputs > 0.[/i]\nEach of the four wireless inks behave like a globally connected Or gate.",
  "So far we've learned the fundamentals for creating circuits in [t]VCB[/t] using the several [t]Trace and Component Inks[/t], and this is already enough to build some very simple circuits. However, soon enough we'll find ourselves limited by the physical constraints of the two-dimensional space of the board, with the biggest challenge being how to use traces to connect different components when there are other traces blocking the way.\n\nThis is where the [t]Space Optimization Inks[/t] come in, they give us the freedom that we need to create compact circuits in [t]VCB[/t]. In the next pages we'll take a look at each ink on this group, starting with the most fundamental of them, the Cross. But first you should know that:\n\n[t]1.[/t] Although it's more common to use the Space Optimization inks with traces they [i]work the same with components[/i].\n\n[t]2.[/t] Except for the Bus the Space Optimization inks [i]do not interact with one another when placed side by side[/i], requiring either a trace, component, or bus between them.",
  "[t]Cross inks[/t] can be placed at the center of perpendicular [t]junction of traces or components[/t] to allow them to coexist independently while crossing one another. Cross inks can be only one pixel wide and must be placed at least one pixel apart, i.e. they don't chain/stack.\n\nIn the two examples on the top of the [i]Circuit 1[/i] we can see the valid usage of cross inks to prevent vertical and horizontal entities from merging while crossing one another. The bottom two examples show invalid usages of cross inks.\n\nDo not forget that crosses [t]can be used with components[/t] too (like logic gates), as shown in [i]Circuit 2[/i].",
  "The [t]Tunnel[/t] behaves similarly to the Cross ink but based on the concept of a [t]pair of entrance and exit points[/t] that can be placed further apart.\n\nFor example, a gate, trace, or bus that touches a tunnel ink [i](entrance)[/i] from the left side will connect to the first tunnel [i](exit)[/i] to the right of the entrance that has the same type of ink touching its right side, where there can be anything in the space between the entrance and exit, even [t]other tunnels for different inks[/t] as shown in [i]Circuit 1[/i].",
  "The [t]Mesh[/t] is a more versatile alternative to the Wireless inks. It works similarly to the tunnel by allowing traces, buses, and components touching meshes in [t]different locations of the board[/t] to merge together.",
  "The [t]Bus[/t] ink allows multiple gates and traces to [t]pass through the same space[/t] on the board.\n\nThere are 6 color variants for the Bus, and like traces of different colors they also [t]merge together when in touch[/t].",
  "Lastly, [t]VCB[/t] also features inks which don't interact with circuits but can be used for aesthetic or documentation purposes:\n\n[t]Annotation[/t] - Meant to be used to drawn annotations on the board.\n[t]Filler[/t] - Meant to be used to fill in the empty space between inks in a circuit, so it can also be painted in the decoration layers.\n\nBoth the decoration and filler inks behave the same and can be used interchangeably, the descriptions above are just the suggested usage. The reason for the existence of those two similar inks is that it makes it possible to remove just one from a circuit while keeping the other by using the Filter option of the drawing tools.\n\nFor convenience the [t]None[/t] ink (i.e. empty space) was also made available in this category, being most useful when used in the Filter to restrict drawing only to empty areas.",
  "Building circuits in [t]VCB[/t].",
  "[t]VCB[/t] has several drawing tools to make building circuits an effortless task, they are:\n\n[t]Array[/t] - a very customizable tool to draw multiple pixels simultaneously.\n[t]Pencil[/t] - draw with a large brush.\n[t]Eraser[/t] - erase pixels from the board.\n[t]Color-picker[/t] - pick an ink to make it the active one.\n[t]Selection[/t] - move, copy, paste, duplicate and more.\n[t]Bucket[/t] - fill areas with the same color.\n\nThere’s also a few special features available for some tools, like the [t]Filter[t].",
  "The [t]Array tool[/t] is the most versatile in the game. It is meant to make the process of [t]drawing multiple traces[/t] or evenly spaced components much easier.\n\nIn the tool options we can change the amount of pixels to draw simultaneously, as well as their spacing and angle. We can also enable the very convenient [t]Auto-cross[/t] option, which automatically takes care of putting a [t]cross ink[/t] whenever we draw over a non-empty space.\n\nHold [t]shift[/t] to activate the [t]axis constraint[/t] while drawing to make straight lines easier.",
  "The [t]Filter[/t] is a feature available for the Array, Pencil and Eraser tools, it allows us to specify which inks we want to paint over. \n\nThis makes it very easy to change the color of a trace without affecting the surrounding ones. It also allows us to draw exclusively in empty areas without accidentally painting over something.",
  "[t]Blueprints[/t] are an easy way of sharing small segments of our circuits with others without having to send the entire project file. They work by copying the selected part of the circuit to the [t]clipboard as text[/t], which we can share with others however we wish. The reverse process is just as easy, we just need to copy the text to the clipboard then click the button that pastes the blueprint back to the circuit board.\n\nThe [t]Blueprint[/t] feature is available through the [t]Selection tool[/t].\n\n[i]Note: the blueprint specification is available at the end of the User Guide in the Appendix chapter.[/i]",
  "When the game is in simulation mode the component and trace inks will have different colors than they do in the editor to indicate their activation state. An ink will have a bright color when the entity it represents (i.e. a component or trace) is [t]ON[/t], and it will have a dark color when it is [t]OFF[/t]. \n\nHowever we can customize these colors by switching to the [t]decoration layers[/t] while editing, they allow us to override the default colors of inks during simulation for each activation state. This enables us to heavily customize the aesthetics of our circuits.\n\nInks that are neither components nor traces (like annotation, filler, and cross) are affected only by the [t]Decoration Low[/t] layer, because those inks are never in an [i]activated[/i] state.\n\nUsing the [t]selection tool[/t] we can also [t]drag and drop[/t] an external image to apply on top of our circuit in the [t]decorations layers[/t].",
  "[t]1.[/t] Get used to the Array tool (and its features), it is the most versatile in [t]VCB[/t]’s toolset, followed by the Selection tool.\n\n[t]2.[/t] Take a look at the [t]Sample Projects[/t] included with the game to get inspired.\n\n[t]3.[/t] The game [t]autosaves[/t] every three minutes and before entering simulation mode. Autosaves can be loaded in the [i]Recently Saved Projects[/i] menu.\n\n[t]4.[/t] The pencil tool allows you to draw thick lines, but you should use it very sparingly since it wastes building space.\n\n[t]5.[/t] Use the available [t]shortcuts[/t].\n\n[t]6.[/t] Ink symbols can be shown for traces too by right-clicking the Ink Symbols button.",
  "[t]1.[/t] Use the simulation controls to change the [t]simulation speed, pause[/t] it, and to advance it [t]step-by-step[/t].\n\n[t]2.[/t] Don’t forget that during simulation we can [t]interact with latch[/t] components using the mouse.\n\n[t]3.[/t] Keep an eye on the Event Log card of the Circuit Editor panel, it displays relevant compilation and simulation warnings.\n\n[t]4.[/t] During simulation we can highlight the entire length of a trace or component by hovering it with the mouse while the Highlight Hovered Entity feature is enabled. The feature can be toggled with the \\\"sparks\\\" button at the top right corner of the interface.\n\n",
  "In [t]VCB[/t] we can build a lot of things using only inks, but some projects may have specific requirements that make them very difficult or impossible to replicate with traces and components, be it due to size constraints, complexity, performance, or the need for some special behavior.\n\nFor those cases we have the [t]Virtual Devices[/t], they are specialized tools at out disposal to build even more advanced circuits. We'll take a look at each of them in the next pages.",
  "The Virtual Memory, or [t]VMem[/t] for short, has [t]2²⁰ addressable words of 4 bytes[/t]. This is a little over [t]one million rows of 32 bits[/t] to store up to 4 MiB of data, which should be enough to hold the most ambitious programs in [t]VCB[/t]. Note that we don’t have to use all the 32 bits available per word, e.g. when we are working with an 8-bit computer.\n\nCircuits can read and write to the [t]VMem[/t] using two sets of components that behave just like latches but have specific purposes: one set is used to write the [t]memory address[/t], and the other is used to read and write the [t]memory content[/t]. Those special components are placed by the game when the simulation is about to start, but we can configure their position while editing the circuit in the [t]VMem Settings[/t] menu. Circuits can access the Virtual Memory during simulation one address at a time, to [t]read or write[/t] data.",
  "[t]When interfacing with the VMem you should follow its three guidelines[/t]\n\n[t]1.[/t] Multiple VMem-latches of the [t]same[/t] type (either address or content) can be changed in the same tick.\n\n[t]2.[/t] Address and content latches should [t]not[/t] be changed in the same tick, it results in undefined behavior.\n\n[t]3.[/t] The VMem will be fetching the memory content in the tick following an address change (i.e. changing the address takes 2 ticks), in the meantime the address and content latches will [t]not[/t] respond to signals. This means that the address latches should [t]not[/t] be toggled at every tick.\n\n[t]On locked latches and ripple-carry based counters[/t]\n\nIf you observe a strange behavior of every other [i]address latch[/i] apparently not working as intended it means that an accidental violation of the guideline number [t]3[/t] is taking place, most likely caused by the usage of a ripple-carry counter to increment the VMem address. Since this type of counter usually switches its bits at every tick it is not suitable to be used with the VMem without some kind of buffering circuit. \n\nAnother alternative would be replacing the ripple-carry counter with a synchronized carry-lookahead one that sets all the [i]address latches[/i] in the same tick.",
  "The [t]Virtual Display[/t] allows us to build screens with a higher pixel density and color depth than would be possible using LED components and all the circuitry required to drive them.\n\nIt features [t]eight indexed color modes[/t] to render images based on a [t]customizable palette[/t], and a [t]RGB mode[/t] to render 16M+ colors. The several modes makes it possible to choose the [i]best balance between color depth and memory footprint[/i].\n\nThe [t]VDisplay[/t] can have any resolution as long as it fits inside the board and has a total of 2¹⁸ pixels or less. Additionally, its buffer pointer can be modified during simulation.\n\n",
  "With the [t]Virtual Input[/t] we can extend our range of interaction with circuits during simulation beyond toggling latches with the mouse.\n\nThis virtual device makes it possible to bind the input from our real life [t]keyboard[/t] directly into an array of components in the board.",
  "Programming in [t]VCB[/t].",
  "To make the creation of programmable computers easier [t]VCB[/t] implements an [t]Assembler[/t].\n\nThe programs we write in the Assembly Editor are assembled to machine code and stored in the Virtual Memory.",
  "Before we can start writing programs we must understand how exactly the game assembles the text we write into [t]machine code[/t]. To do that, the first concept that we must get familiar with are [t]primitives[/t].\n\n[t]Primitives[/t] are for us the building blocks to write programs, and for the assembler the atomic pieces of information used to fill the Virtual Memory.",
  "A primitive is a [t]number[/t] that can be either [t]literal[/t] (e.g. -5, 0b0001, 0xFF) or [t]non-literal[/t] (e.g. foo, bar, baz). Non-literal primitives are [t]aliases[/t] to their literal counterparts and need to be [t]defined[/t] in order to be used. Some of them can be undefined when not needed anymore, or redefined to alias another numeric literal. There are three types of non-literal primitives: Symbols, Pointers, and Labels.\n\nBefore we take a closer look at each type of primitive let's see how the assembly's syntax is structured and where the primitives fit into it.",
  "[t]VCB[/t] assembles code in [t]statements[/t] separated by [i]newlines[/i] or [i]semicolons[/i]. They can be either [t]directives[/t] or [t]instructions[/t]:\n\n-> [t]Directive[/t] statements tell the assembler to define, redefine, and undefine non-literal primitives, but notice that they [t]do not contain[/t] the primitives themselves.\n\n-> [t]Instruction[/t] statements are [t]made of[/t] literal and non-literal primitives defined in directive statements, they are the actual [t]data[/t] of a program.\n\nDuring assemble all the primitives (numbers) in an instruction are bitwise [t]OR[/t]ed* together and put into an address of the VMem. \n\n*Unless an [i]expression[/i] is detected.",
  "We can override the automatic [t]OR[/t]ing in instructions by using operators to form expressions. They allow us to perform bitwise and arithmetic operations with the primitives to determine how they will be evaluated before being stored in the VMem.\n\nExpressions can only be used in instructions and not in directives. Operators must have spaces between them, except the parentheses [b][cy]()[/cy][/b]. The operators are:\n\n[b][cy]+[/cy][/b] Addition\n[b][cy]-[/cy][/b] Subtraction\n[b][cy]*[/cy][/b] Multiplication\n[b][cy]/[/cy][/b] Division\n[b][cy]%[/cy][/b] Modulo\n[b][cy]~[/cy][/b] Bitwise NOT\n[b][cy]&[/cy][/b] Bitwise AND\n[b][cy]|[/cy][/b] Bitwise OR\n[b][cy]^[/cy][/b] Bitwise XOR\n[b][cy]<<[/cy][/b] Bit shifting left\n[b][cy]>>[/cy][/b] Bit shifting right\n[b][cy]([/cy][/b] Begin subexpression\n[b][cy])[/cy][/b] End subexpression",
  "[code][ca]>[/ca] [cy]symbol[/cy] [cv]foo[/cv] [cg]0b0001[/cg]\n[ca]>[/ca] [cv]foo[/cv] [cg]0b1000[/cg][cy];[/cy] [cg]0xF7[/cg][/code]\n\nIn the above example we have 3 statements, the first is a [t]directive[/t] and the two others are [t]instructions[/t]. The directive is just defining a primitive named [t]foo[/t], and it won’t be assembled into machine code as it does not contains any data. \n\nBut the following statement, [t]foo 0b1000[/t], does have primitives, two of them: it has the non-literal [t]foo[/t] (0b0001) defined earlier, and a numeric literal (0b1000). These two primitives will be [t]OR[/t]ed together to become a single instruction (0b1001) which will be stored in the Virtual Memory, followed by the 3rd statement in the next address.",
  "When the game starts to assemble instructions into machine code it [t]skips the first word[/t] of the Virtual Memory (address 0 is reserved and should not be used) and starts at address 1. The assembled data is stored in [t]big-endian order[/t] with negative values represented in [t]Two's Complement[/t].\n\nThe assembler ignores blank lines and comments in the code, which are indicated with a [t]#[/t] symbol.\n\n[code][ca]>[/ca] [ce]# This is a comment.[/ce]\n[ca]>[/ca] [cv]psh[/cv][cy];[/cy] [cv]cal[/cv] [cb]Print[/cb][cy];[/cy] [cv]ret[/cv] [ce]# Another comment.[/ce][/code]\n\nNow that we’ve learned about the assembly’s syntax and how instructions become machine code we can take a closer look into each type of [t]primitive[/t].",
  "[t]Numerics[/t] are the literal primitives. They must be in the range of 32 bits to fit into the words of the Virtual Memory.\n\n[code][ca]>[/ca] [ce]# Base 10, hexadecimal, and binary are all supported.[/ce]\n[ca]>[/ca] [cg]10515545[/cg][cy];[/cy] [cg]0xFFFF[/cg][cy];[/cy] [cg]0b01101010[/cg] [ce]# Negative numbers are also ok.[/ce][/code]\n\n[code][ca]>[/ca] [ce]# Floating points are[/ce] [cr]not supported[/cr][ce].[/ce]\n[ca]>[/ca] [cg]3.14[/cg][cy];[/cy] [cg]2.71[/cg][cy];[/cy] [cg]0.333333[/cg] [/code]\n\nUnderscores can be used in numerics to improve readability.",
  "[t]Symbols[/t] are the primitives for user-defined values, they are useful to create [t]mnemonics[/t] for opcodes. They must be defined with an [t]identifier[/t] followed by a [t]numeric literal[/t]. Optionally they can be redefined or undefined.\n\n[code][ca]>[/ca] [cy]symbol[/cy] [cv]add[/cv] [cg]0xFF[/cg] [ce]# Definition: “add” from now on means “0xFF”.[/ce]\n[ca]>[/ca] [cy]resymb[/cy] [cv]add[/cv] [cg]125[/cg] [ce]# Redefinition: “add” from now on means “125”.[/ce]\n[ca]>[/ca] [cy]unsymb[/cy] [cv]add[/cv] [ce]# Undefinition: “add” no longer exists.[/ce][/code]\n\nSymbols are highlighted in purple if they are not undefined at the end of the code, otherwise they default to red.\n",
  "[t]Pointers[/t] are the primitives for memory addresses. Due to the pointer’s nature a statement that defines it is [t]both a directive and an instruction[/t]. A pointer can be defined with a [t]numeric literal[/t] or have one automatically assigned to it using the [i]inline[/i] keyword. With the former the pointer is stored in the specified address instead of coming after the previous statement. Use [t]repoint[/t] and [t]unpoint[/t] to delimit its scope.\n\n[code][ca]>[/ca] [ce]# Puts the number 30 in the address 0xFF, now aliased to “foo”.[/ce]\n[ca]>[/ca] [cy]pointer[/cy] [cr]foo[/cr] [cg]0xFF 30[/cg] [ce]# The address must be a literal primitive.[/ce]\n[ca]>[/ca] [ce]# Puts the number 5 between the previous and next instructions.[/ce]\n[ca]>[/ca] [cy]pointer[/cy] [cr]bar[/cr] [co]inline[/co] [cg]5[/cg] [ce]# “bar” now points to the unknown address.[/ce][/code]",
  "[t]Labels[/t] are also primitives for memory addresses, with a few key differences: 1. They point to the [t]first instruction[/t] that comes after their definition; 2. They [t]cannot be undefined[/t]; and 3. They have [t]global scope[/t] and can be used in statements that come [t]before[/t] their definition. Labels can be defined with the [t]@[/t] symbol.\n\n[code][ca]>[/ca] [cy]@[/cy] [cb]Sum[/cb]\n[ca]>[/ca] [cv]lia[/cv] [cg]10[/cg][cy];[/cy] [cv]ldb[/cv] [cr]value[/cr][cy];[/cy] [cv]add[/cv]\n\n[ca]>[/ca] [cy]@[/cy] [cb]MyOtherFunction[/cb]\n[ca]>[/ca] [cv]psh[/cv][cy];[/cy] [cv]cal[/cv] [cb]Sum[/cb][cy];[/cy] [cv]ret[/cv] [ce]# “Sum” is an alias to lia 10’s VMem address.[/ce]",
  "We write assembly code using [t]statements[/t] separated by [i]newlines[/i] or [i]semicolons[/i]. [t]Directive[/t] statements define the [t]primitives[/t] (numbers) that we use in [t]instruction[/t] statements, which are the actual [t]data[/t] of our programs.\n\nThe assembler takes all the primitives in an instruction and [t]OR[/t]s them together, unless we form an expression using operators. The resulting number is then put in the [t]Virtual Memory[/t] in the next address after the last instruction assembled. \n\nThe [t]pointer[/t] primitive is special because its definition or redefinition is [t]both a directive and an instruction[/t]. The statement defining a pointer will be put in the specified address of the Virtual Memory, unless the [i]inline[/i] keyword is used.",
  "Bookmarks provide a [t]quick way to navigate[/t] through our code by adding labels beside the assembly editor, which we can click to go to the lines where they were defined. Bookmarks are ignored by the assembler, use [t]bookmark[/t] and [t]sub_bookmark[/t] to declare them.\n\n[code][ca]>[/ca] [ca]bookmark[/ca] [cr]FunctionForSum[/cr] [ce]# Topic bookmark.[/ce]\n[ca]>[/ca] [cv]lia[/cv] [cg]10[/cg][cy];[/cy] [cv]ldb[/cv] [cr]value[/cr][cy];[/cy] [cv]add[/cv]\n\n[ca]>[/ca] [ca]sub_bookmark[/ca] [cr]PrintSumResult[/cr] [ce]# Subtopic bookmark.[/ce]\n[ca]>[/ca] [cv]psh[/cv][cy];[/cy] [cv]cal[/cv] [cb]MyFunction[/cb][cy];[/cy] [cv]ret[/cv]",
  "If you would like to use an [t]external text editor[/t] to write the assembly code you may do so by enabling the respective option in the [i]External Editing[/i] menu, located below the [i]Bookmarks[/i] icon in the [i]Assembly Editor[/i] panel. The game will then read the contents of a text file with the same name and path as the current project, ending with the [i]\\\".vcbasm\\\"[/i] extension.\n\nIn the [i]External Editing[/i] menu you also have the option to enable the [i]External base VMem[/i] setting, which will copy the contents of an [t]external binary file[/t] into the VMem every time the simulation starts. Similar to the external assembly file, the VMem file should also share the same name and path as the current project, but ending with the [i]\\\".vcbmem\\\"[/i] extension.\n\n[t]Notes[/t]\n\n[t]-[/t] After enabling the external assembly or VMem option the respective files must be manually created.\n\n[t]-[/t] Since [t]VCB[/t] only reads the external assembly and VMem files they must be manually copied/moved when the current project is saved/moved to another path.\n\n[t]-[/t] The external VMem file is read in big-endian order.",
  "Wrapping up.",
  "[t]VCB[/t] comes with [t]sample projects[/t] to showcase some of the circuits that can be build in the game. The [i]32-bit Computer[/i] project for example features an ALU, an instruction decoder that accesses the VMem, and a scrolling display.\n\nThe sample projects are available through the [t]open book icon[/t] in the top-right corner of the UI.",
  "You should now have all the essential knowledge required to start playing with [t]Virtual Circuit Board[/t], but don’t forget to take a look at the included Sample Projects to see all the theory you’ve learned so far applied in practice.\n\nIf you need any help with [t]VCB[/t] feel free to reach me out in the game’s communities.\n\nI hope you have as much fun playing the game as I’m having developing it!\n\n\n[t]– Mause[/t]",
  "Supplementary information.",
  "This page describes the current blueprint format, introduced in the 0.2 update. Legacy blueprints generated in previous [t]VCB[/t] versions start with [i]\\\"KLUv/\\\"[/i], the new blueprints begin with [i]\\\"VCB+\\\"[/i].\n\nBlueprints use Base64 encoding. Bytes are in big-endian order.\n\n[t]Header[/t]\n3-byte blueprint identifier (VCB+)\n3-byte blueprint version\n6-byte checksum (truncated SHA-1) of the remaining characters of the blueprint string\n4-byte width\n4-byte height\n\n[t]Layer Block(s)[/t]\n4-byte block size\n4-byte layer id (Logic = 0, Deco On = 1, Deco Off = 2)\n4-byte uncompressed buffer size\nN-byte zstd-compressed RGBA8 buffer\n\nThe Logic layer block must be present in all blueprints.\n\nDecoration layer blocks are optional but if used both of them must be included.",
  "[i]Virtual Circuit Board[/i]\nCopyright (c) 2022-2023 Reverie Foundry. All rights reserved.\n\n[i]Made with Godot Engine.[/i]\nThird-party licenses are available at the installation directory.",
  "Settings",
  "Focus view",
  "Center",
  "L",
  "R",
  "Position XY",
  "Res. XY",
  "Scale XY",
  "Address",
  "Word Size",
  "Color Depth",
  "Direction",
  "Overview",
  "1-bit, 2 colors from palette,\n32 pixels per VMem address\nordered in big-endian.",
  "Palette",
  "000000, ffffff, ff0000, 00ff00, 0000ff, ff0000, 00ff00, 0000ff, ff0000, 00ff00, 0000ff, ff0000, 00ff00, 0000ff, ff0000, 00ff00",
  "Yellow - most significant bits\nBlue - least significant bits",
  "Error status",
  "Settings",
  "Focus view",
  "All",
  "MSB",
  "LSB",
  "Bits",
  "Address",
  "Position XY",
  "Offset XY",
  "Size XY",
  "Mode",
  "Key Name",
  "Click to Check",
  "Bindings",
  "Q = 0x20\nW = 16\nE = [3]\nR = 0x4\nT = 0b10\nY = 0b1",
  "Yellow - most significant bits\nBlue - least significant bits",
  "Error status",
  "Address",
  "Focus view",
  "All",
  "MSB",
  "LSB",
  "Bits",
  "Position XY",
  "Offset XY",
  "Size XY",
  "Content",
  "Focus view",
  "All",
  "MSB",
  "LSB",
  "Bits",
  "Position XY",
  "Offset XY",
  "Size XY",
  "Legend",
  "Yellow - most significant bits\nBlue - least significant bits",
  "Recently Saved",
  "Project Name",
  "Autosaving",
  "Project Title",
  "Virtual Circuit Board",
  "aaaaaaaaaaaaaaaaaaaaaa",
  "Sample Projects",
  "Project Name",
  "Options",
  "Fullscreen",
  "Settings",
  "Shortcuts",
  "Changelog",
  "About",
  "Quit",
  "Simulate",
  "Simulate",
  "aaa",
  "5000000",
  "365056 IPS",
  "Ink Symbols Overlay",
  "Show",
  "Resolution",
  "Position",
  "Scale",
  "Show",
  "Main Color",
  "BG Color",
  "Digits",
  "Position",
  "Scale",
  "Menu Title",
  "Menu Titleg",
  "Menu Title",
  "Close",
  "Save",
  "Do not show this warning again",
  "Fullscreen",
  "Borderless",
  "V-Sync",
  "Grid",
  "Glow",
  "Dynamic Background",
  "Toggle bookmarks",
  "External assembly and VMem",
  "Load the assembly from a text file with the same path as the project, ending with \\\".vcbasm\\\"",
  "Edit assembly externally",
  "Load the VMem from a binary file with the same path as the project, ending with \\\".vcbmem\\\"",
  "Use external base VMem",
  "Persistent VMem",
  "Follow VMem Address",
  "Layer Logic",
  "Layer Decoration High",
  "Layer Decoration Low",
  "Eraser tool",
  "Undo\n$ed_undo",
  "Redo\n$ed_redo",
  "Draw tool",
  "Array tool\n$ed_tool_array",
  "Pencil tool\n$ed_tool_pencil",
  "Eraser tool\n$ed_tool_eraser",
  "Color picker tool (Alt)",
  "Selection tool\n$ed_tool_selection",
  "Bucket tool\n$ed_tool_bucket",
  "Cross\n$ed_array_cross",
  "Tunnel",
  "Mesh",
  "Bus (right-click to change color)",
  "Write\n$ed_array_write",
  "Read\n$ed_array_read",
  "Trace (right-click to change color)",
  "Buffer",
  "And",
  "Or",
  "Xor",
  "Not",
  "Nand",
  "Nor",
  "Xnor",
  "Latch ON",
  "Latch OFF",
  "Clock",
  "LED",
  "Timer",
  "Random",
  "Use time as seed",
  "Breakpoint",
  "Wireless (right-click to change channel)",
  "Annotation",
  "Filler",
  "None",
  "Adjacent",
  "Square brush shape",
  "Diamond brush shape",
  "Circle brush shape",
  "Filter",
  "Change angle\n$ed_array_rotate_right",
  "Auto-cross toggle\n$ed_array_toggle_autocross",
  "Axis constraint angle",
  "Axis constraint toggle",
  "Toggles the latch when the mouse button is pressed",
  "Sets the latch's state to ON when the mouse button is pressed\nand immediately sets to OFF when the button is released",
  "Toggle view mode for values:\nAbsolute, Percentage.",
  "Toggle view mode for order:\nDefault (Circuit Editor order),\nDescending, Ascending.",
  "Total area drawn. Excluding cells\nwith Annotation and Filler inks.",
  "Total amount of unique traces\nand components in the circuit.",
  "Copy selection",
  "Paste selection",
  "Duplicate selection",
  "Delete selection",
  "Apply selection",
  "Rotate selection left",
  "Rotate selection right",
  "Mirror selection horizontally",
  "Mirror selection vertically",
  "Copy selection as text to clipboard",
  "Paste selection from clipboard text",
  "Include decoration layers when\ncopying and pasting blueprints",
  "Drag and drop an image to insert it as a\nselection in the current layer",
  "Save circuit",
  "Contents",
  "Paste this circuit into the board",
  "Toggle table of contents",
  "用户指南",
  "Figures and circuits",
  "Figure 1 - VCB splash screen.",
  "Circuit 1 - Introduction circuit.",
  "Introduction",
  "Editing and simulating",
  "Simulation engine",
  "User Interface",
  "Navigation and shortcuts",
  "Docking System",
  "Right-click behavior",
  "Virtual Circuits",
  "Drawing-based Interface",
  "Components and Traces",
  "Inks and Entities I",
  "Circuit 1 - Adjacent inks become a single entity.",
  "Inks and Entities II",
  "Circuit 1 - Traces of different colors will merge together.",
  "Flow control I",
  "Flow control II",
  "Circuit 1 - A single trace made out of three color variants, as well as the special trace inks, Write and Read.",
  "Flow control III",
  "Circuit 1 - In this example signals will flow from the Latch to the Buffer, but not the opposite.",
  "Flow control IV",
  "Uncountable connection I",
  "Uncountable connection II",
  "Circuit 1 - LEDs change color based on the amount of active inputs.",
  "Circuit 2 - Another example, using XOR gates.",
  "Multiple IO",
  "Gate Components",
  "General Components I",
  "General Components II",
  "Space Optimization",
  "Cross Ink",
  "Circuit 1 - Valid Cross placements at the top, and invalid at the bottom.",
  "Circuit 2 - A single AND gate connected to three traces.",
  "Tunnel Ink",
  "Circuit 1 - Traces of different colors passing through tunnels.",
  "Mesh Ink",
  "Circuit 1 - Traces remotely connected thanks to meshes.",
  "Bus Ink",
  "Circuit 1 - Multiple entities can pass through the same cells using buses.",
  "Annotation Inks",
  "Editing",
  "Tools",
  "Array Tool",
  "Blueprints",
  "Layers",
  "Edit mode tips",
  "Simulation mode tips",
  "Virtual Devices",
  "Virtual Memory I",
  "Virtual Memory II",
  "Virtual Display",
  "Virtual Input",
  "Assembly",
  "Overview",
  "Assembly language",
  "Primitives",
  "Statements I",
  "Expressions",
  "Statements II",
  "Assembler",
  "Primitives - Numerics",
  "Primitives - Symbols",
  "Primitives - Pointers",
  "Primitives - Labels",
  "Review",
  "Bookmarks",
  "External Editing",
  "Conclusion",
  "Sample Projects",
  "Figure 1 - 32-bit Computer included in the sample projects.",
  "Developer's Note",
  "Appendix",
  "Blueprint Specification",
  "About",
  "Enable Virtual Display",
  "Visible in Edit mode",
  "Move camera to\nthe display's center",
  "Move camera to the\ndisplay's top left corner",
  "Move camera to the\ndisplay's bottom right corner",
  "The location of the pointer to the video buffer.\n\nIf THIS field is set to 1024, for example, the Virtual Display will go to\naddress 1024 in the VMem and use the value stored THERE as the\npointer to the actual location of the image to render.\n\nThis behavior makes it possible to swap the rendered image at once by\nchanging the buffer location (in this case stored at address 1024) to\nanother position in memory containing the data to a different image.",
  "Maximum amount of bits to use for pixel data per VMem word.\n\nThe VDisplay will use the largest multiple of the Color Depth\nsmaller than the Word Size as the amount of pixels per word.\n\nFor example, if the Color Depth is set to 3-bit and the Word Size\nis set to 16, the VDisplay will operate with the lowest 15 bits of\nwords (i.e. 5 pixels) and ignore the highest 17 remaining bits.",
  "Direction at which pixels are drawn. Both modes render from\nthe top-left corner of the Virtual Display to its bottom-right.\n\nHorizontal - draws in rows from left to right, top to bottom.\nVertical - draws in columns from top to bottom, left to right.",
  "Enable Virtual Input",
  "Move camera to\nthe interface bits",
  "Move camera to the\nMost Significant Bit",
  "Move camera to the\nLeast Significant Bit",
  "Press - active while the input keys are pressed.\nPulse - active for a single tick.",
  "Bindings are separated with newlines\nand defined with the syntax:\n\n<key_name> = <value>\n\nThe binding's value can be written as a\nnumber (binary, base 10, hexadecimal),\nor alternatively as a list of bits:\n\n\\\"[3, 1]\\\" is equivalent to \\\"0b1010\\\".",
  "Enable VMem",
  "Move camera to\nthe address bits",
  "Move camera to\nthe content bits",
  "New project\n$fs_new_project",
  "Open project\n$fs_open_project",
  "Save project\n$fs_save_project",
  "Save project as",
  "Open recently saved and\nauto-saved projects",
  "Undo last action",
  "Redo last action",
  "new_circuit.vcb",
  "Beta build",
  "User guide",
  "Open sample projects",
  "Options",
  "Save circuit as",
  "Toggle left sidebar\n$ui_toggle_left_sidebar",
  "Open project",
  "Save project",
  "Compile only the visible portion of the board. This can be\nuseful to view the statistics of a specific area in the circuit.",
  "Toggle game mode",
  "Previous step\n$sm_prev_update",
  "Start simulation paused",
  "Pause simulation\n$sm_pause_simulation",
  "Next step\n$sm_next_update",
  "Ticks to advance in Step Mode",
  "Target simulation speed\nRight-click to type a value instead",
  "Target simulation speed\nRight-click to use a slider instead",
  "Render with decoration layers",
  "Highlight hovered entity",
  "Allow Virtual Input to consume\nkeyboard input from binded keys",
  "Display ink symbols when zoomed-in.\nRight-click to toggle symbols for traces",
  "Show traces symbols",
  "Flat rendering",
  "Toggle assembly editor",
  "Display",
  "Target simulation frequency",
  "Toggle right sidebar\n$ui_toggle_right_sidebar",
  "Circuit Editor",
  "Assembly Editor",
  "Notes",
  "User Guide",
  "VMem Settings",
  "Swap panel",
  "Maximize dock",
  "The User Guide"
]